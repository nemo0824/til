<!-- 함수형 프로그래밍 과 객체 지향형 프로그래밍 -->

프로그래밍 패러다임의 진화

1. 절차지향형 프로그래밍
2. 객체지향형 프로그래밍
3. 함수형 프로그래밍

2.객체지향형 프로그래밍
실세계의 객체를 모델링하여 소프트웨어를 개발하는 방법론
클래스와 객체의 기반으로하며 상속화, 다형성, 캡슐화

장점
유지보수성, 재사용성
독립적인 단위로 존재
각 객체는 자신의 데이터 행동을 가지고있다
복잡한 시스템을 여러 객체로 분리하여 관리해주며 대규모 프로젝트에 적합

단점
상태를 가지는 객체들사이의 상호작용은 때때로 예측하기어려운 부작용을 발생
복잡한 시스템에서 상태 관리의 어려움을 초래한다
성능저하: 객체 생성과 상속구조로 인해 성능이 낮아질수있음
과도한 추상화 : 필요이상의 추상화로 인해 오히려 이해하기어려운 코드가될수있따

3. 함수형 프로그래밍

함수형 프로그래밍은 순수함수와 불변성을 중심으로 소프트웨어를 설계하고 개발하는 패러다임입니다
FP는 수학적 함수 개념에 기반하여 부작용을 최소화하고 코드의 예측 가능성 재사용성을 높입니다

1.순수함수
같은 입력에 대해 같은 출력을 반환합니다
외부 상태를 변경하지않으며 부작용이없습니다

2. 불변성
   데이터는 변경되지않으며 변경이 필요할 경우 새로운 데이터를 생성합니다

3. 고차함수
   함수를 인자로 받거나 함수를 반환하는 함수입니다

4. 함수 합성
   여러개의 함수를 합성하여 새로운 함수를 만든 기법

5.선언적 프로그래밍
어떻게 명령하기보다 무엇을 해야하는지 선언해줍니다

6.재귀
반복문 대신 재귀를 사용하여 반복작업을 수행합니다

장점
가독성
테스트 용이성 : 순수함수는 부작용이없음으로 테스트 용이
병렬 처리 : 불변성을 통해 데이터 경쟁 조건없이 병렬 처리가 용이합니다
재사용성 : 작은단위의 순수함수는 재사용하기 쉽습니다

단점
학습곡선 : oop에 비해 개념이 추상적일수있다
퍼포먼스 이슈 : 불변성 이슈로인해 메모리 사용량이 증가될수있따
디버깅 어려움 : 함수 합성이나 고차함수 사용 시 디버깅이 어려울수있다

병행사용
현대 자바스크립트에서는 oop, fp 를 병행해서 많이 사용하는데
데이터처리는 FP로 애플리케이션 구조 상태관리는 oop로 많이사용한다고함

그런데 여기서 데이터처리는 연산과 같이 데이터를 정제하는거로 이해를 했고

애플리케이션 구조 상태관리? 란 뭘까??? 생각해보게됐다
애플리케이션 구조란?
소프트웨어 애플리케이션이 어떻게 조직되어있고 모듈화되며 구성요소들이 상호작용하는지를 정의하는개념
아키텍쳐왁 관련있으며 코드의 유지보수성, 확장성 , 가독성에 큰 영향을 끼칩니다

모듈화(Modularity): 애플리케이션을 독립적인 모듈이나 컴포넌트로 분리하여 관리.
레이어링(Layering): 기능을 여러 계층(예: 프레젠테이션, 비즈니스 로직, 데이터 접근)으로 나눔.
디자인 패턴(Design Patterns): 공통적인 문제를 해결하기 위한 재사용 가능한 솔루션 (예: MVC, MVVM).
컴포넌트 기반 설계(Component-Based Design): 독립적인 컴포넌트로 애플리케이션을 구성.

<!-- http와 https 의 차이  -->

http vs https

http, https는 기본적으로 웹상에서 데이터를 주고받는 데 사용되는 대표적인 프로토콜

http는 클라이언트와 서버 간에 html,문서, 이미지, 텍스트,파일 등 웹콘텐츠를 주고받기위한 프로토콜이고
TCP 위에서 동작하면서 80 포트를 사용한다
HTTP 요청 메시지를 통해서 서버에 원하는 리소스를 요청하고 서버는 이에 대한 응답 메시지를 보내는 고자ㅓㅇ을 거친다
HTTP는 이렇게 통신할때 평문을 보내게된다 (암호화한것 아님)

http는 3가지 약점을 가지고있다

1. 평문 통신이기때문에 "도청"가능
2. 통신 상대에를 확인할수없기때문에 "위장"가능
3. 완전성을 증명할수 없기 때문에 "변조" 가능 (완전성이란 ==> 상대측에서 보낸게 바뀌지않았는지 즉 무결성)

4. 평문 통신이기에 도청이가능하다
   TCP/IP 구조의 통신 내용은 전부 통신 경로를 도중에 엿볼수있다

1-1) 통신의 암호화
HTTP에는 암호화 구조가없는데 SSL, TLS 라는 다른 프로토콜을 조합하여 HTTP 통신애ㅛㅇ을 암호화할수있다
안전한 통신로를 확립하고나서 그통신로르 사용해 HTTP 통신을 한다

1-2) 콘텐츠 암호화
통신하고있는 콘텐츠 내용의 자체를 암호화하는 방법 HTtp에 암호화하를 하는 기능은없슴
HTTP를 사용해서 운반하는 내용을 암호화하는것
HTTP 메시지에 포함되는 콘텐츠만 암호화하는것
메시지 헤더 , 메시지 바디로 구분했을때 메시지 헤더는 암호화하지않고 메시지 바디 안에들어가는 콘텐츠만 암호화한다

2. 통신 상대에를 확인할수없기때문에 "위장"가능
   누구나 리퀘스트를 할수있다 상대가 누구인지 확인하는 처리가 없기때문

2-1) 상대를 확인하는 증명서
HTTP에서는 통신 상대를 확인할수없지만 SSL로 상대를 확인할수있음
SSL은 암호화 뿐만아니라 상대를 확인하는 수단으로 증명서를 제공하고있슴

증명서는 제3자기관에 의해서 발행되는것이기때문에 믿을만하다

3. 완전성을 증명할수 없기 때문에 "변조" 가능 (완전성이란 ==> 상대측에서 보낸게 바뀌지않았는지 즉 무결성)
   상대가 수신할때까지 사이에 변조되었더라도 이사실을 알수가없다

MD5, SHA-1 등의 해시값을 확인하는 방법과 디지털 서명을통해서 구별할수있음

https

http는 소켓을 통해서 서버에 연결한뒤 해당 소켓위에서 http 요청을 주고받는다
https는 tcp소켓연결 이후 먼저 TLS핸드셰이크를 통해서 보안 세션을 설정한다 여전히 TCP소켓을 사용하지만 TLS프로토콜을 통해 암호화 레이어를 형성한뒤 그 터널 안에서 HTTP를 전송한다

공통키 교환 ==> 공개키 교환 ==> 하이브리드(암호화(공개키), 메시지내용(공통키))

tls,ssl 핸드셰이크를할떄
비대칭키 암호화를 이용하여 대칭키를 안전하게 교환하고 데이터통신은 대칭키 암호화로한다

<!-- 브라우저의 렌더링 -->

브라우저 렌더링 웹 페이지 렌더링

1-1. 사용자가 주소창에 google.com 을 입력

1-2. 브라우저는 DNS를통해서 www.google.com 도메인에 해당하는 IP주소를 조회한다

1-3. IP주소를 얻은뒤 브라우저는 해당 서버에 https 연결을 시도한다
https 핸드셰이크 TLS를 통해 암호화된 통신 채널을 설정한후 GET요청을 서버에 전송한다

2-1 서버응답수신(HTML문서로드)
서버로부터 초기 HTML 문서가 응답으로 돌아온다
최소화된 HTML 구조와 css, 이미지, 검색

3 HTML파싱, DOM 트리 생성
브라우저는 받은 HTML을 파싱하면서 DOM트리를 만든다
중간에 script 태그를 만나면 해당 스크립트를 다운로드하고 실행되게된다

4 CSS파싱 로드 와 CSSROM 트리 생성

5.DOM + CSSOM -> 렌더트리 구성
브라우저는 DOM 과 CSSOM을 결합해 렌더 트리를 만든다

6. 레이아웃계산 ---리플로우(width, height, padding, margin)
   렌더트리를 기반으로 각 요소의 정확한 위치와 크기를 계산한다
   각 요소가 페이지 내에서 어느위치 x, y 어떤크기 margin,paadding, border, display 모든 css규칙을 고려해서 상대적 위치를 결정
   정확한 위치와 크기에 대한 정보

7.페인트 단계 --리페인트(font, 색상)
레이아웃 바탕으로 각 렌더 트리 노드를 실제 픽셀로 변환한다
레이아웃으로 부터 얻은 기하 정보에따라 "어떻게 그릴지" 결정
폰트,색상,배경,테두리,그림자,이미지 시각적 스타일을 고려하여 "픽셀"로 표현

8. 합성 단계
   페이지를 여러 레이어로 분리할수있다
   모든레이어가 GPU가속을 통해 빠르게 합성되어 최종화면을 형성한다

예전에는 동적효과들이 늘어나면서 모든 변화시 전체 페이지를 다시 페인트하는방법을 사용했는데 엄청 비효율적이였슴
현대 브라우저는 페이지를 여러 레이어로 분리하여 각 레이어를 독립적으로 업데이트하고 마지막에 GPU로 빠르게 합성

미리 그려진 이미지(레이어) 들을 모아 한장의 화면으로 합쳐내는 과정 이를 통해 작은 부분 변화는 해당되는 레이어만 재조정하면되기때문에
전체 페이지를 다시그릴필요가없다

9. 사용자 인터렉션 반영
   js를 통해서 사용자의 인터렉션이 반영된다

<!-- 3번 html파싱 dom트리생성시 script태그를 만나게되는데 만나게 되면 어떻게 되는지 -->

태그를 만나면 기본적으로 html 파싱이 중단되고 해당 스크립트를 다운로드받고 즉시 실행한다
===> 초기렌더링 지연, 표시 속도가 느려짐

문제해결을 위한 방식

1. 전통적방식 html태그의 하단에 배치
   html파싱이 거의 끝난시점에 스크립트 로딩하기때문에 초기렌더링이 빨라질수있음
   이방식은 dom이 완성된 후에 스크립트를 로드해서 스크립트실행시점엔 DOM이 준비되어있어 상호작용이 가능한상태
   ==>여전히 스크립트 로드 시점에 브라우저 차단되긴함

2. 최산방식 script태그에 async defer 속성을 사용하면 스크립트 로딩과 실행시점을 제어할수있다 비동기적으로 로드, 파싱을 방해하지않으며 실행시점을 제어할수있다

2-1 async
html파싱과 스크립트 다운로드를 병렬로 진행한다

==> 독립적인 기능일경우 사용 (광고, 추적)

2-2 defer
html파싱과 스크립트 당누로드를 병렬로 진행
DOM파싱이 모두될떄까지 스크립트 지연

 <!-- 개발하기에 따라 다르겠지만 CSR과 SSR의 각각언제 개발해야 유리한지? -->

클라이언트사이드(CSS)

-초기 로딩 HTML이 거의 비어있음 JS를 통해 동적으로 콘텐츠를 로딩하고 렌더링하는방식 -초기 로딩 속도 낮음 -데이터가 필요하면 api 서버에 요청하고 받은 JSON 데이터를 바탕으로 화면만 갱신 -한번 로드하게되면 페이지 전환속도가 빠름 사용자의 경험 좋음

서버사이드(SSR) -최초 요청시 서버에서 HTML을 완성된 형태로 제공하기때문에 초기로딩속도가 빠르고
-SEO(검색 엔진 최적화에 유리함) -클라이언트와 상호작용이많은경우에는 매번 서버에 요청을 보내야함으로 반응성이 떨어짐 -사용자가 다른페이지 이동시에 브라우저는 다시 서버에 요청하고 서버는 새로운 html을 그려야함

<!-- 트래픽 서버부하 트레픽 분포 측면에서는? -->

서버사이드

- 매 페이지마다 서버가 html을 조립하고 렌더링함으로서 서버에 부하가 큼

클라이언트사이드

- 초기 로딩 이후 많은 로직이 브라우저에서 동작함으로서 서버의 부담을 줄일수가있슴
- 서버는 단지 API를 통해 데이터만 전달하고 클라이언트가 이를 해석하기때문에 서버 스케일링이 더 단순해질수이씀

<!-- 요즘의 서버사이드렌더링은? -->

-요즘은 서버사이드 렌더링을 이용하여 초기로딩은 서버사이드렌더링을 사용해서 ==> SEO, 초기렌더링을 빠르게이용하고 -이후에는 CSR로 상호작용을 향상시키는 전략을 사용합니다

<!-- 왜 서버사이드는 ? 검색엔진 최적화 즉 SEO에 유리할까? -->

검색엔진 크롤러 (봇) 어 html 문서를 로딩하고 그 안의 내용을 바탕으로 인덱싱을한다
--검색엔진 크롤러의 처리능력차이
--빠른 초기 콘텐츠 인식
--JS비의존성
--메타정보 구조화 안정적 제공

1. 클라이언트 사이드
   ==> 따라서 클라이언트사이드느 애초에 html 빈껍대기(스켈레톤)만 받고 모든 컨텐츠는 JS실행이 전제되며
   ==> 크롤러가 JS를 완전히 실행하지 않거나 실행에 제약이있는경우 콘텐츠를 제대로 파악하지 못할수도있슴

2. 서버사이드
   서버에서 미리 HTML을 구성한 상태로 응답함으로 크롤러는 추가적인 JS 없이도 콘텐츠를 직접 HTML에서 확인가능함
   이는 크롤러가 페이지의 텍스트, 메타태그, 링크 정보를 즉시 파악하고 인덱싱하기 쉽게 만듭니다

검색 엔진 크롤러가 서버에서 렌더링된 완전한 HTML을 받음으로 컨텐츠 인덱싱에 유리하다
블로그, 뉴스사이트 , 쇼핑몰 등 검색 유입에 중요성이 높은 서비스라면 서버사이드가 좋다

<!-- SEO유리하게 하는방법  -->

1,페이지로딩속도 2.구조화된 데이터 (JSON) 3.모바일친화성
모바일 사용자가 웹사이트를 편리하게 사용할수있도록하는 페이지를 우선적으로 노출하려고한다

<!-- 검색 엔진 봇의 인덱싱과정 -->

1. 크롤링
   검색엔진봇이 웹사이트를 방문하여 페이지의 html 구조를 가져온다
2. 렌더링
크롤링한 html파일을 분석하여 컨텐츠의 구조를 파악한다 3.인덱싱
렌더링된 페이지의 컨텐츠를 데이터베이스에 저장한다
검색쿼리에 빠르게 응답하기위해서 저장된 키워드 주제등으로 정리
<!-- 시멘틱 태그는 어떻게 영향을 줄까? 검색엔진에? -->

1.컨텐츠 구조화 명확히
검색엔진 봇이 페이지의 정보를 더 명확하게 파악할수있게해줌

2.콘텐츠 맥락 파악 용이
문맥도 이해 상승시켜 검색 결과품질 개선에 기여합니다

3.콘텐츠 접근성 용이

<!-- 시멘틱 태그에 스크린 리더?  -->

--명확한 문서 구조 제공

시멘틱태그는 스크린리더 와 같은 보조기술이 페이지를 해석하고 사용자 (시각장애가있는) 음성으로 제공할때 유리

시멘틱태그는 단순히 시각적으로 구분하는게아니라
의미적 구조를 반영한다 사용자에게 문서의 어디에있는지 확인 쉽게 파악가능하게한다

--콘첸츠 탐색용이
스크린리더 사용자간에 문서내에서 섹션간에 빠른이동 jump 가 가능

--의마전달과 맥락 제공

<!-- html 파싱 -->

브라우저에서 ==> 서버로 요청을 핝다 관련 url로

1. 서버는 2진수로 브라우저측에 html을 전송한다
2. 브라우저는 2진수로 된걸 인코딩해서 볼수있도록한다
3. 브라우저측에서는 파싱을한다 (토큰형태로 분해)
4. 브라우저측에서 파싱된HTML 토큰을 Node 형태로 변환하면서 트리구조를 나타낸다
5. 노드들이 모여 DOM 트리가된다

<!-- 트래픽 폭증시 해결방법 -->

1. vertical 스케일링
   서버의 "성능"을 향상시켜서 처리 용량을 증가시키는 방법
   비용적인 측면이 단ㄷ점
   로드밸런싱이나 구조적 복잡성이 낮음
2. Horizontal 스케일링
   서버의 "수"를 늘려서 처리 용량을 증가시키는 방법
   비용적인 측명에서 장점
   로드밸런싱이나 구조적 복잡성이 높음

프론트엔드 측면

1. CDN
   이미지, css, js 같은 정적리소스를 CDN에 배포해서 트래픽을 분산시킨다
   사용자와 가깐운 CDN서버에서 리소스를 제공해서 응답시간이 줄어든다
   오리진서버에 요청하지않고 중간에 CDN에서 받아오게된다

2. 서버요청 최소화
   사용자와 관련없는 데이터를 불필요하게 요청하지않도록 API 호출을 최소화
   특정 데이터가 자주 변경되지않는다면 프론트엔드 캐싱을 활용

디바운스 쓰로틀린

3. 중요 데이터만 먼저 로드하기
   -lazy loading 사용자가 보지않는 컨텐츠를 지연로딩

4. 로드 밸런싱에 친화적인 UI설계ㅖ -대기열 표시

- 비동기작업으로 응답 지연 처리

5. 프리렌더링
   서버사이드를 이용해서 그러면 html 처음로드가 빠르니까
   사전에 렌더링할수있게끔한다
   <!-- 스레드 싱글스레드 vs 멀티스레드 -->
   스레드란?
   스레드는 프로세스 내에서 실행되는 가장작은단위의 실행 흐름
   한 프로세스는 하나이상의 스레드를 가질수있다
   운영체제에서 프로그램은 프로세스로 실행된다
   모든 스레드는 동일한 프로세스 내에서 메모리를 공유하며 독립적으로 실행됩니다

싱글스레드?

싱글스레드는 하나의 스레드만을 사용하는 프로그래밍 모델입니다
프로그램 한번에 하나의 작업만 처리할수있습니다

작업은 순차적으로 진행됩니다
한 작업이 완료되기전까지 다른작업은 실해오디지않는다

장점: -단순성
프로그램이 한번에 하나의 작업만 처리하므로 코드가 간단하고 디버깅이 쉽다 -스레드간 데이터 충돌이없슴
하나의 스레드만 실행됨으로 공유자원의 관리가 필요없다 -낮은 메모리 사용량
스레드가 하나만 동작함으로 메모리소마가 적다 -레이스컨디션같은걸 신경쓰지않아도된다

단점: -작업 병렬처리 불가
CPU가 여러 코어를 가지고있어도 하나의 작업만 처리함으로 성능이제한됨 -블로킹문제
한작업이 CPU를 오래 점유하거나 I/O작업에서 멈추면 전체 프로그램이 멈춤

멀티스레드?
멀티스레드는 하나의 프로세스 안에서 여러 스레드가 동시에 실행되는 모델
프로그램이 동시에 여러작업을 병렬적으로 처리할수있음

장점 -병렬처리가능
작업을 나누어 여러 스레드에서 동시에 처리함으로 대규모 작업처리 시간이 단축
-CPU효율 극대화
멀티코어 CPU의 자원을 최대한 활용 -반응성 향상
사용자 인터페이스와 백그라운드 작업을 분리하여 프로그램이 더 빠르고 응답성이 좋아짐

단점 -복잡성이증가
스레드간의 동기화 관리가 필요
코드 디버깅 테스트가어려움 -높은 메모리소비
여러 스레드가 생성되므로 메모리 사용량이 증가. -데드락
두스레드가 서로의 자원을 기다리면서 멈춰버리는 상황발생가능

자바스크립트는 기본적으로 싱글스레드 방식으로 동작한다  
그러나 자바스크립트에서 싱글스레드 방식으로 동작하는건 브라우저가 아니라 브라우저에 내장된 자바스크르비트 엔진이라는것을 기억해야한다
만약 모든 자바스크립트 코드가 자바스크립트 엔진에서 싱글스레드방식으로 동작한다면 비동기적으로 동작할수없다
즉 자바스크립트 엔진은 싱글스레드 방식으로 동작하지만 브라우저는 멀티 스레드로 동작한다

<!-- 컴파일 언어 인터프리터 언어 -->

인터프리터 언어/ 컴파일언어

인터프리터언어
한줄씩 읽고 해석하면서 바로실행
실행은 빠르지만 매번해석해야함으로 반복실행은 느림

컴파일언어
전체코드를 미리 기계어로 변환한후 실행
컴파일 후 실행은 빠름 컴파일 시점에서 시간소요

javascript는 초기에 인터프리터 방식으로 동작했다
인터프리터는 코드를 한줄씩 읽고 바로실행하기 때문에 컴파일언어에 비해 개발속도가 빠르고 동적 타입언어로 유연성이 높았다

현대 js (JIT컴파일러포함)
최신 js엔진 v8 에는 just in time 컴파일러를 사용한다
jit 컴파일러는 실행중에 인터프리터가 코드를 해석해주면서 자주실행 되는
코드를 기계어로 변환하여(컴파일) 성능을 최적화한다

인터프리터와 JIT컴파일러의 혼합형 모델로 동작하여
유연성과 성능을 모두 추구한다

현대 js엔진 동작과정 (v8) 1.파싱한다 js 소스코드를 읽어서 추상구문트리(AST)라는 자료구조로 변환 2.바이트 코드 생성 AST기반으로 바이트 코드생성 3.실행 바이트코드는 즉시실행되며 실행중 성능데이터 수집한다
자주실해오디는 성능이 중요한 코드는 JIT컴파일러가 최적화하여 컴파일함 4.최적화디옵티마이제이션
JIT컴파일러는 코드를 최적화하여 실행속도를 높입니다

인터프리터의 특성 -빠른개발 디버깅 곧바로실행할수있기때문 -동적타입과 유연한 문법 -브라우저에서 콘솔에서 즉시실행가능

컴파일러 특성
-JIT컴파일러를 통해 실행속도를 크게 향상 -컴파일된 코드는 최적화시켜 네이티브 코드로 실행됨으로 반복 실행시 성능이 매우빠르다

<!-- nodejs  -->

node js는 chrome V8 js 엔진 위에서 동작하는 js 런타임환경입니다
원래 js는 브라우저에서 클라이언트 측 프로그래밍 언어로만 사용되었지만 node.js 를 통해서 서버사이드에서도 js를 사용할수있게되었습니다

js
자바스크립튼 DOM API를통해 html 문서를 조적하고 이벤트를 처리하는 클라이언트 측 언어로동작

제한된 환경에서 동작하기때문에 파일시스템, 네트워크 데이터베이스 접근 불가능

node.js
브라우저없이 js실행할수 있는 런타임환경
DOM API 제공하지는 않음 대신 파일시스템 , http 모듈,데이터베이스 연결등 서버측 기능을 제공

Node js 읱 ㅡㄱ징

1. 비동기 이벤트기반 및 논 블로킹 i/o

- node js 논블로킹 i/o 아키텍처를 통해 대규모 네트워크 요청 처리에 매우 효율적
- 이벤트루프를 기반으로 비동기 작업을 처리한다
- 한요청이 처리되는 동안 다른요청도 동시에 처리가능

2. 모듈기반 설계

- 기본제공 모듈을 통해 다양한 서버작업을 쉽게 처리할수있다

3. NPM
   node.js는 NPM 을 통해 수천개의 오픈소스 라이브러리를 간단하게 설치하며 관리할수있다
4. 싱글 스레드기반
   node.js는 싱글스레드 기반으로 작동하지만 백그라운드 작업은 스레드 풀을 사용하여 처리함

단점:
cpu 집약적인 작업에는 부적합(싱글 스레드기반)

스레드풀은 미리 생성된 스레드 집합으로 작업이 필요할떄 새로운 스레드를 생성하는 대신 기존의 스레드를 재사용하여 작업을처리한다

논블로킹i/o 아키텍처란?
작업을 요청한뒤 바로 다음작업을 시랳ㅇ합니다 작업이 완료되면 콜백함수로 처리합니다
요청/응답 처리가 오래걸리는 작업을 이벤트 루프와 스레드 풀로 관리하여 병렬적으로 처리할수있다 (파일읽기/네트워크 요청처리/ 데이터베이스 쿼리)

<!-- 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임, stoppropagation, preventDefault() -->

이벤트 버블링
이벤트 버블링은 dom에서 하위 요소에서 발생한 이벤트가 상위 요소로 전파되는 전파 방식을 말한다
즉 이벤트가 특정 요소에서 발생하면 해당 이벤트가 부모요소를 통해 최상위 요소로 전파된다
DOM은 트리구조로 이루어져있기때문에 이벤트는 특정요소에서 발생한후 전파된다

1. 캡쳐링단계
2. 타깃단계
3. 버블링단계

캡쳐링은 ==> window => document => parent => child => button
타깃 ==> button
버블링 ==> button => child => parent => document => window

stoppropagation
evnet.stopPropagation() 메서드를 사용하면
이벤트가 상위요소나 하위요소로 전파되지않느다

preventDefault()
기본적인 역할을 제제한다 ==> 예를 들면 a태그를 이거사용하면 페이지가 넘어가지지않음

이벤트위임
이벤트 버블링을 활용하면 효율적으로 이벤트 처리를 관리할수있다
이벤트 위임은 부모요소에 이벤트 리스너를 추가하고 이벤트 버블링을 활용하여 하위요소의 이벤트를 처리하는방법이다

여러개의 버튼이 추가되더라도 부모요소의 하나의 이벤트 리스너로 처리가능하다

<!-- async , await, Promise 객체  -->

<!-- async defer둘의 차이점 -->

async와 defer는 html에서 script태그 속성으로 사용되어 비동기적으로 스크립트를 로드할때 쓰인다

둘의 실행시점과 방식에는 차이가있다

1.  async 속성
    비동기적으로 로드 스크립트가 로드되는 동안 html파싱이 중단되며 로드가 완료되면 즉시 실행합니다
    => 즉 비동기적으로 로드하니까 html파싱, 스크립트다운로드 동시에 진행 다운로드받다가 다 되면 html파싱을잠시맘추고 실행 그리고 이어서 html파싱
    ===> 순서 보장 x

실행시점: 스크립트가 준디된 즉시 실행되기때문에 스크립트간 순서가 보장되지 않는다
용도:
독립적인스크립트(다른 스크립트에 의존하지않는 경우)
페이지에 큰 영향을 미치지않느 스크립트
광고 스크립트, 웹분석도구, 소셜 미디어 위젯

2.defer
비동기적으로 로드 스크립트를 비동기적으로 다운로드 html파싱은 중지하지않는다
==> 즉 비동기적으로 로드하니까 html파싱, 스크립트다운로드 동시에 진행 다운로드받다가 다 돼도 html파싱이 끝난뒤에 실행
실행시점: html파싱이 완료된후 실행된다 스크립트 실행순서가 보장된다
용도: 의존관계가 있는 스크립트(순서가 중요한경우)
dom 조작이 필요한경우 (dom 이 모두 파싱된후 실행함으로 안전)

3.기본
비동기적으로 로드하지않음
html 파싱하다가 script 태그를 만나면 스크립트를 다운로드하고 실행이 끝날때 까지 파싱이 멈춘다

<!-- DOM -->

DOM은 Document Object Model HTML또는 XML문서의 구조를 프로그래밍적으로 조작할수 있도록 제공하는 트리 구조 기반의 모델
브라우저가 HTML문서를 읽으면 DOM트리로 변환
HTML문서의 각 요소가 객체로 변환되어 계층적 구조를 가지게됨

DOM 의 모든 구성 요소는 노드
JavaScript는 브라우저가 제공하는 DOM API를 사용해 DOM을 조작하고 조정하는 역할
HTML 파싱 → DOM 트리 생성
CSS 파싱 → CSSOM (CSS Object Model) 생성
DOM + CSSOM 결합 → Render Tree 생성
Layout: 요소의 크기와 위치 계산
Painting: 화면에 요소를 그립니다.
Reflow & Repaint: DOM이나 CSS가 변경되면 렌더링을 다시 수행합니다.

DOM 조작이 많아질수록 성능 저하가 발생할 수 있기 때문에 최적화가 중요

DOM 관련 기술 확장
Virtual DOM: React 같은 라이브러리에서 사용하는 개념으로, 실제 DOM 조작 대신 메모리상에서 가상 DOM을 업데이트하고 이를 실제 DOM과 비교해 필요한 부분만 업데이트
Shadow DOM: 웹 컴포넌트에서 사용되는 기술로, DOM 트리의 일부를 캡슐화하여 외부 스타일이나 스크립트의 영향을 받지 않도록 함

<!-- 렌더링비용? -->

렌더링 비용은 브라우저가 화면을 다시그리기 위해서 사용하는 리소스(cpu, 메모리시간)
DOM이 변경될때 브라우저는
1.Reflow
2.Repaint

DOM을 계속 조작할떄 비용이 크게발생하는 이유는 ==> 브라우저 렌더링 엔진이 변경사항을 감지하면 Reflow, Repaint를 수행하기때문

렌더링비용을 줄이는법

1. DOM 조작 최소화
   여러번 DOM을 수정해야할경우 한번에 조작하는게 좋다
   width reflow 1회 repaint 1회
   height reflow 2회 repaint 2회
   backgroundcolor repaint 3회
   총 reflow 2회 repaint 3회

style = width height 한번에 1회 2. VirtualDOM사용
VirtualDOM은 DOM 변경사항을 메모리상의 가상DOM에 적용하고 실제 DOM과 비교해서 변경이필요한 부분만 업데이트
Reflow, Repaint 최소화

3. 애니매이션 및 스타일 최적화
   애니매이션이나 스타일 변경은 가능하면 GPU가속이 가능한 속성만 변경한다

==> 브라우저는 화면에 내용을 렌더링할때 CPU와 GPU를 사용한다
모든 스타일 변경이 GPU 가속을 받는것은아님
transform, opacity
이속성들은 레이아웃계산이나 Reflow를 일으키지않는다
즉 브라우저가 layout 계산없이 GPU를 사용해 REpaint만을 일으키기때문에 성능이 좋다

<!-- virtual DOM -->

virtual DOM은 브라우저의 Reflow와 Repaint를 최소화하기 위해 등장한기술

기존 DOM을 직접조작하면 자주발생하는문제점

1. 여러번 DOM 변경 => 매번 Reflow, Repaint발생
2. 성능저하 => 반복적으로 Reflow가 발생하면 페이지가 느려진다

Virtual DOM 의 최적화

1. 메모리상에 가상 DOM을 생성
   실제 DOM 대신 메모리상에서 가상의 DOM을 변경

2. Diff 알고리즘 (변경사항 비교 알고리즘)
   변경된 VirtualDOM과 기존 VirtualDOM을 비교한다
   변경된 부분만 파악

// 가상의 DOM에 업데이트

virtualDOM.style.width = "200px";
virtualDOM.style.height = "200px";
virtualDOM.style.backgroundColor = "red";

// 실제 DOM에는 최종 결과만 업데이트 → Reflow & Repaint 1회만 발생

<!-- SPA CSR단점 한계? -->

1. 초기 로딩 속도 문제
   SPA에서는 필요한 JS번들 파일을 모두 다운로드후 애플리케이션 실행한다
   초기 JS파일이 크면 다운로드 및 파싱/컴파일에 시간이 걸려 초기속도가 느려질수있습니다

초기화면이 표시되기까지의 FCP 및 TTI가 느려진다

===> 코드스플리팅 : 필요한 자바스크립트를 페이지별로 분리하여 초기 크기를 줄인다
===> Lazy loading : 사용자와 관련 ㅇ벗는 컴포넌트나 리소스에 나중에 필요할떄 로드한다

<!-- SPA CSR에서 부드럽다고 느끼는이유 -->

기존방식은 MPA방식 multip Page Applicaiton

페이지 전환시마다 브라우저가 새로운 HTML, css ,js를 서버에서 받아온다
이과정에서 브라우저는 전체 페이지를 새로고침함으로 페이지가 깜빡이는 현상이 발생한다
사용자에게 느껴지는 경험은 딜레이가 있는 불연손적인 전환

CSR방식
SPA구조에서는 클라이언트가 필요한 데이터만 서버에요청하고 DOM의 특정부분만 업데이트
현재페이지를 유지한상태에서 DOM을 업데이트하여 전체 페이지 새로고침 없이 부드럽게 전환된다

<!-- 스태틱 사이트 제네레이션 SSG -->

Static site generation
정적인 HTML 파일을 빌드시점에서 미리 생성해서 사용자 요청이들어왔을때 즉시 제공하는방식
정적인 페이지는 서버에서 처리없이도 클라이언트에 바로 표시가능하기때문에 성능과 SEO에서장점

1. 기본원리
   빌드시점에 HTML 생성
   서버나 프레임워크가 사전에 데이트를 가져와서 HTML파일을 생성
   이 html파일은 CDN과 같은 네트워크를 통해 사용자에게 즉시제공

정적인 HTML파일
빌드된 결과물은 단순 html, css, js파일로 구성 서버에서 별도의 처리 x

2. 특징
   빠른 페이지 로딩속도
   SEO최적화
   보완성
   서버가 동적으로 데이터를 처리핮않아서 공격의 표면적이 줄어듦
   운영비용절감
   섭가 필요하지않거나 최소한의 서버사용해도 운영가능

단점
동적인 데이터 처리 어려움
빌드시간이 길어질수 있음 (많은페이지를 생성하는 대규모사이트에는 빌드 시간이 오래걸림)
사용자 맞춤 컨텐츠 어려움(모든 사용자에게 동일한 HTML제공)

서버사이드 렌더링과의 차이점

SSR

1.  html생성시점
    사용자가 페이지를 요청하면 실시간으로 서버에서 html을 생성한다
    즉 서버는 요청이 들어올때마다 데이터를 가져오고 html을 렌더링후 브라우저에 전달한다

2.  특징
    동적인 데이터 처리할수있음
    사용자 맞춤형 콘텐츠 제공가능
    매번 html을 실시간 생성 ==> 서버부하 응답시간 늘어날수있음
    실시간 변경되는 데잍거많은 페이지

SSG
1.html생성시점
빌드시점에 미리 HTML생성한다
서버는 이미 만들어진 정적인 HTML 파일을 요청 시 브라우저에 즉시 전달

2. 특징
   빌드시점에 데이터를가져와 html 페이지를 생성
   CDN을 통해서 배포
   매우빠른 로딩 서버가아니라 CDN에서 정적 파일을 제공 속도가 빠름
   SEO 최적화 미리 만들어져서
   실시간 데이터 처리 어려움 HTML고정이기때문에 데이터를 자주변경하려면 재빌드해야함
   서버 부담이 낮음 동적 렌더링이없음으로 서버리소스가 절약됨

사용사례 : 블로그, 문서화 사이트, 렌더 페이지처럼 변경이 정적인 콘첸츠

<!-- 원시값이 왜 객체처럼 동작하는이유 wrapper 객체 -->

wrapper Object 래퍼 객체

원시값의 특징 ==> 변경이 불가능한 불변성을가진 데이터타입
원시값은 객체가 아니므로 프로퍼티나 메서드를 가질수없다
근데 왜
string.length 같은게 가능할까?

래퍼 객체 : 원시값을 객체처럼 다룰수있게해주는 매커니즘

자바스크립트는원시값에 접근할때 자동으로 래퍼 객체를 생성한다
이래퍼 객체는 원시값을 일시적으로 객체로 변환해 프로퍼티나 메서드에 접근할수있도록 돕는다

작동과정

1. 원시값에 속성이나 메서드를 호출하면 ===> 자바스크립트엔진은 래퍼객체를 생성한다
   "abc".length 호출하면 String 객체가 생성된다

2. 래퍼 객체는 원시값을 기반으로하고 그 타입에 맞는 메서드나 프로퍼티를 제공한다

3. 메서드 호출이나 프로퍼티 접근이 끝나면 래퍼객체는 즉시 삭제된다
   ==>: 원시값은 여전히 원시값으로 남아있고 객체로 변환된적이있다는 흔적은 없어짐

<!-- 래퍼 객체와 프로토타입 체인의 관계 -->

원시값은 프로토타입 체인을 직접가지지않는다
ex "abc" 자체는 프로토타입 체인을 가지지않는다

하지만 래퍼객체 자체 (String, Number)는 프로토타입 체인을 가진다
그래서 "abc".length 때 생성된 String이라는 래퍼객체는 내부적으로 String.prototype을 참조할수있다
String.prototype에 정의된 메서드 (length, toUpperCase)사용가능

즉 원시값은 객체가아니지만 자바스크립트 엔진은 원시값을 접근할때 래퍼객체를 생성하고 이 객체는 원시값을 일시적으로 감싼다
해당 타입에 맞는 메서드나 프로퍼티를 제공한다 작업끝나면 래퍼객체는 사라지고 원시값만 남는다
원시값이 직접 프로토타입 체인을 가지는것은아님
래퍼객체를 통해 프로토타입 체인을 사용할수있음

<!-- 부동소수점 -->

64비트 부동소수점
자바스크립트의 숫자(number)는 IEEE 754 표준을 따릅니다.
이 표준에 따라 모든 숫자는 64비트(8바이트) 크기를 가지며, 이를 통해 정수와 소수를 모두 표현할 수 있습니다.
8바이트의 구성
1비트: 부호(Sign) → 양수(0) 또는 음수(1).
11비트: 지수(Exponent) → 숫자의 범위를 표현.
52비트: 가수(Fraction) → 숫자의 정확도를 표현.

<!-- 불변성 메모리 구조와 관련해서-->

1. 불변성이란?
   불변성은 데이터가 생성된후 변경되지않는 속성
   값을 변경하려고할때 기존의 값을 수정하는게아니라 "새로운 메모리공간에 새로운값을 할당한다"

2. 원시값들(기본형) 특징 구조
   +symbol

원시값들(기본형)은 메모리의 변수영역과 데이터영역중에
데이터영역에들어간다 변경이불가능함 5002

ex) let a = 10; //메모리영역에 10 저장
a = 20 ;//새로운 메모리영역에 20저장
a가 20으로 변경되는것처럼보이지만 실제로는 새로운 메모리주소에서 새로운값이 할당된것

3. 불변성과 메모리 구조
   자바스크립트 엔진은 메모리를 스택, 힙으로 나눠서 관리

기본형은 -스택영역에 저장
불변성을 가지므로 값을 변경하려고하면 새로운 메모리공간이 할당된다

변수영역(stack), 데이터 영역(heap)

불변성의 장점 1.예측가능한코드
데이터가 변경되지않음으로 값추적쉬윔 2.메모리 관리효율
기본형값은 크기가작고 불변함으로 스택에서 효율적으로관리 3.함수형 프로그래밍 유용
상태 변겨하지않고 데이터를 사본으로 생성

<!-- 멀티패러다임언어 , 상속-->

멀티패러다임 언어는 여러 프로그래밍 패러다임을 지원하는 언어를 뜻한다
프로그래밍 패러다임 문제를 해결하기 위한 코드 작성방식

1. 객체지향 프로그래밍 : 클래스와 객체중심으로 설계
2. 함수형 프로그래밍 : 순수 함수와 상태 불변성강조
3. 절자척 프로그래밍 : 순차적으로 명령실행
4. 반응형 프로그래밍 : 비동기 데이터흐름 처리

자바스크립트는: 객체지향 , 함수형, 비동기적프로그래밍

상속은 객체지향 프로그래밍의 핵심개념중하나
한클래스가 다른클래스의 속서오가 메서드를 물려받는것
상속을 통해 코드의 재사용성 높이고 계층구조를 통해 구조화할수있따

1.  부모클래스
2.  자식 클래스
3.  오버라이딩
4.  다중상속

프로토타입 기반 상속
자바스크립트는 ES6 이전에 클래스 대신 프로토타입을 사용하여 상속을 구현
객체가 다른 객체를 참조하여 상속 관계를 형성

<!-- 웹 취약성에따른공격유형들 -->

OWASP Top 10

1. xss(cross=site-scripting)
   공격자가 악의적인 js코드를 삽입하여 피해자의 브라우저에서 실행되도록한다
   주로 입력값 검증이 부족한 경우 발생
   1-1 저장형 stored xss
   악의적 스크립트가 데이터베이스에 저장되고 다른사용자에게 노출
   댓글, 게시판 프로필 소개등에 스크립트 삽입

1-2 Reflected xss (반사형 xss)
사용자 입력값이 서버를 통해 즉시 반환될떄 발생
예) 검색 쿼리에 script alert(1)
1-3 DOM-Based XSS
클라이언트 사이드에서 DOM 조작을 통해 실행
예) js로 inner HTML 직접 수정

==> 입력값검증,
===> csp 스크립트 실행제한 및 외부리소스 차단
====> innerhtml 대신 textContent사용 2. CSRF(Cross-site Request Forgery)
사용자가 신뢰한 사이트 권한을 이용하여 의도치 않은 요청을 전송하도록 유도
피해자가 로그인한 상태에서 악의적인 요청을 수행

공격 시나리오:
사요자가 은행 웹사이트에 로그인한 상태
공격자는 사용자를 유도하여 악의적인 링크를 클릭하도록함
해당 링크가 사요자의 인증저보를 포함하여 돈을 이체

==> CORS정책 설정
===> Reffer 헤더를 확인해서 신뢰된 도메인에서만 접근허용
===> CSRF 토큰사용 CSRF서버에서 토큰생성해서 요청에 포함 요청시 서버가 검증할수있도록

<!-- script 태그 async defer 차이 -->
<!-- CSR SSR 차이 사용자 경험 관점에서, SSG -->
<!-- Critical Rendering Path -->

Critical Rendering Path (주요 렌더링경로)
브라우저가 html, css, js를 처리하여 웹페이지리르 렌더링하는 과정

1. html 파싱
   html 문서 다운로드 및 파싱
   DOM 생성

2. css 파싱
   css 파일 다운로드 및 파싱
   cssom (css ojbect Model) 생성

3. DOM + CSSOM 결합 => 렌더링 트리 생성
   DOM 과 CSSROM을 결합시켜서 렌더링 트리를 생성
   브라우저가 렌더링할 요소와 스타일 지정

4. layout(Reflow)
   각 위치와 크기 계산
   각 요소의 좌표 크기 계산
   보이고 안보이는 요소
   padding , width, height , margin 등등

5. paint (Repaint)
   요소의 색상, 텍스처 , 그림자를 칠함
   픽셀을 캔버스에서 렌더링

6. composite(합성단계)
   여러 레이어를 합성하여 최종으로 화면에 그린다

Critical Rending Path 의 최적화 방법

1.  css최적화
    css가 렌더링을 차단한다
    Rendering Tree를 생성할때까지 css를 모두 파싱해야하기떄문

    최적화방법

    1. 최소화 : css파일 크기 축소
    2. 비동기로딩 : media 속성사용
    3. Critical css 적용 : 초기 렌더링에 필요한 css 인라인삽입

2.  javascript 최적화
    js가 렌더링으 ㄹ차단한다
    js는 DOM 생성과 CSSROM 파싱을 차단한다
    실행되기전까지 렌더링을 멈추게만든다

    최적화방법

    1. 비동기로딩 async, defer
    2. 필요한 스크립트만 로드 : 초기렌더링에 필요하지않은 script는 로드하지안흔다
    3. 크기 최적화 js코드 최소화 번들링

3.  이미지 최적화

        최적화방법
        1.Lazy Loading
        2.이미지 포맷 최적화
        3. 반응형 이미지 제공

<!-- 0.1 + 0.2 !== 0.3 -->

부동소수점
자바스크립트는 모든 숫자가 64비트 부동소수점으로 저장된다 => 8바이트
실수(소수)를 저장할때 근사치 값으로 저장한다

부호 1비트 + 지수 11비트 + 기수, 소수점이하 52비트

부호 : 숫자가 양수인지 아닌지 결정
지수 : 소수점을 어디에 놓아야할지 결정
기수 : 실수값을 표현

문제의 원인
컴퓨터는 2진수로 계산함 ==> 10진수의 일부 소수는 2진수로 정확하게 표현되지않음

무한 반복 소수 저장시
메모리에저장될떄 52 비트까지만 저장된다 ==> 정확하게 저장되장ㄴㅎ고 반올림으로 저장

해결방법

1. 반올림 처리 ==> toFixed()
2. 오처 허용 범위 설정 ==> NumberEPSILON
3. 정수 연산 활용 ==> 계산 전 정수로 변환,

<!-- 가비지 컬렉터 알고리즘 -->

참조카운팅

- 객체가 참조될때마다 잠초 카운트 증가 참조가 제거될때마다 카운트 감소
- 즉 카운트가 0 이면 가비지컬렉팅 동작

===> 근데 두객체가 서로참조할경우에는 참조 카운트가 0 이되지않음 메모리 누수발생

마크 앤 스위프
javascript 엔진에서 사용하는 V8 기본 가비지 컬렉팅 방식
루트 객체 로부터 접근가능한지 여부만 판단함

1.  Mark(마크)
    모든 객체에 도달가능여부를 체크
    도달 가능한 객체에 Mark 표시를 남김
2.  Sweep(싀위프)
    도달할수없는 객체를 메모리에서 해제

==> 참조카운팅의 단점을 해결해준다
루트 객체 로부터 접근가능한지 여부만 판단해주기때문에 단점을 해결해준다

<!-- JSON, JSONstringfy말고 깊은복사할때 잃는점 단점 -->

1. 함수 및 메서드 손실
   JSON은 함수를 지원하지않아서
   객체 내부에 함수가있을때 무시되거나 손실됨

2. symbol 손실
   symbol 타입은 직렬화되지않는다

3. undeifned손실
   객체 내 undefined 값은 제거된다

4. Data 객체 손실
5. set. Mapa 객체 손실

순환참조불가, 프로토타입 손실, 메모리 효율성 부족

<!-- 순환 참조 -->

순환참조는 객체가 자기자신을 참조하거나 서로 참조하는 객체간의 참조루프가 발생하는것
let obj ={}
obj.self = obj

순환참조는 그래프구조 Json 포맷은 트리구조
따라서 순환참조 객체는 직렬홥 가능

<!-- TDD 와 Jest -->

TDD 테스트 주도 개발

코드를 작성하기전에 테스트 코드를 먼저 작성하는 개발방법론

1. Red(실패)
   먼저 테스트 코드 작성 > 실행하면 실패

2. Green(성공)
   테스트가 통과하할수있또록 최소환의 코드 작성 - > 테스트성공

3. Refacotr(리팩터링)
   코드의 가독성/성능 최적화 -> 테스트가 꺠지지않도록 유지

Jest
1.Matcher사용 매치를 제공하여 값을 비교 검증한다 2.비동기테스트
비동기 코드도 쉽게 테스트할수있따

<!-- 이벤트핸들러 -->

이벤트 핸들러는 함수의 호출시점을 대신 위임하는것임

1.  함수호출문 => 적합 x 함수를 대신호출해줘야하는데 이미 결과값이나오기때문
2.  함수참조문
3.  고차함수

<!-- 이벤트핸들러 등록ㄷ방식 -->

1.  이벤트 핸들러 어트리뷰트 방식(inline)

<button onclick="alert('Clicked!')">Click Me!</button>

html 태그 속성 어트리부트로 직접 이벤트 핸들러 등록
이벤트 핸들러 함수이름이나 코드 블록은 문자열로 지정가능

확장성 부족,
xss 보안문제

2. 이벤트 핸들러 프로퍼티방식(DOM프로퍼티)
<script>
  const btn = document.getElementById('btn');
  btn.onclick = function () {
    alert('Clicked!');
  };

</script>

자바스크립트 코드에서 DOM 요소를 직접 설정해서 이벤트핸들러를 등록
html, js 코드가 분리되서 유지보수 향상
코드 실행 순서가 동적으로 관리됨

중복 핸들러 등록 불가
이벤트 옵션관리 불가 => 캡쳐링, 버블링 설정 불가

3. addEvnetLisner 방식
   권장됨
   캡쳐링/버블링 제어가능

evnetlisner 목록만들어서 핸들러 관리
여러 핸들러 queue형태로 처리

여러 핸들러 등록가능
useCaputer옵션으로 캡쳐링/버블링 제어가능

동작원리---------
이벤트 발생시 addEvnetlisenr는 등록된 핸들러들을 "큐" 에저장함
이벤트가 발생하면 큐에 저장된 핸들러들을 등록순서대로 실행한다
덮어씌어지지않음

useCaputer 옵션 (캡쳐링, 타겟, 버블링)

<!-- 호이스팅 -->

        var

            선언과 초기화가 호이스팅 시점에 동시에 이루어짐.
            따라서 TDZ 없음.

        let

            호이스팅 시 선언만 됨(초기화 X).
            초기화는 선언 이후 코드 실행 시점에서 이루어짐.
            그래서 초기화 전까지 TDZ(일시적 사각지대) 발생.

const

    호이스팅 시 선언만 됨(초기화 X).
    초기화가 반드시 선언과 동시에 이루어져야 함.
    선언 전에 접근하면 TDZ 발생.
    재할당 불가.

<!-- TDZ(Temporal Dead Zone, 일시적 사각지대) -->

let, const 변수는 선언되어씾만 초기화되기 전까지 접근할수 없는 구간
호이스팅은 되었지만 TDZ에 걸려 초기화 이전 접근시 오류발생

<!-- eslint, prettier -->

<!-- etag 등 -->

ETAG는 서버가 리소스의 고유한 식별자를 생성하고
이를 클라이언트에 전달하는 http 응답헤더
리소스가 변경되었는지 여부를 판단하는데 사용
캐싱 성능을 향상시키고 불필요한 데이터 전송을 줄여서 네티워크 최적화

첫번째 요청
브라우저가 ===> 서버 리소스요청
서버는 리소스 전달 및 리소스 ETAG값 생성하여 응답
Etag: "abcd123"

두번쨰 요청
브라우저는 ETAG저장후 리소스를 다시 요청할때 if-None-Mach 헤더에 이전 ETAG를 추가
If-None-Match: "abcd123"

서버는 요청 ETAG값과 현재 리소스의 ETAG값을 비교함
변경된 내용이없으면 304응답받고 브라우저는 캐시된 파일을사용한다

변경되었으면
새로운파일과 새ETAG 반환

<!-- doctype -->
<!DOCTYPE>

문서 유형 선언
브라우저에게 이 문서가 어떤 html버전을 사용하는것인지 알려주는 역할

브라우저는 <!DOCTYPE> 선언 여부와 내용에 따라 렌더링모드를 결정한다
렌더링 모드 3가지

1. 표준모드
2. 쿼크 모드
3. 부분 표준 모드

<!-- 이벤트위임  -->

이벤트위임은 자식요소의 이벤트 처리를 부모요소에 위임하는 기법
메모리 절약과 최적화 달성

각 자식에 직접 이벤트핸들러를 추가하면 비효율적
DOM 요소가 많을경우 메모리 사용 증가 => 각 요소마다 이벤트핸드럴가 개별로 할당하기때무네
동적 추가 요소에는 이벤트 적용불가

<!-- package.json -->

프로젝트 메타데이터와 의존성관리
프로젝트의 설정파일로 프로젝트의 정보를 담고있다
프로젝트의 이름, 버전, 설명, 작성자, 라이센스
의존성 : 필요한 라이브러리 및 버전 정보
스크립트 : npm 명령어로 실행할수있는 명령정의

<!-- package-lock.json -->

package.json에 명시된 버전보다 더 구체적인 버전 정보를 저장
의존성 트리를 기록 하위 의존성까지 고정

프로젝트의 모든 개발자가 동일한 의존성 버전을 설치하도록 보장

<!-- node_modules -->

실제 라이브러리 파일 저장소
프로젝트에서 사용하는 모든 패키지의 코드와 의존 파일을 저장
하위 의존성까지 포함하여 실제 코드가 이폴더에 설치
프로젝트에 필요한 패키지 설치할떄 생성

설치된 패키지를 로컬에서 사용할 수 있도록 저장.
빌드 또는 실행 시 라이브러리 참조.
node_modules는 용량이 크기 때문에 Git 저장소에는 포함시키지 않음(.gitignore 처리)

npm 동작 원리
package.json 의 의존성을 기반으로 필요한 패키지 설치
설치된 패키지는 node_modules에 저장
설치된 정확한 버전 정보는 package-lock.json에 기록

<!-- for in / for of -->

for in
객체의 속성값 "key" 반복
배열일시 인덱스 반복
객체의 속성 반복가능
상속된 속성 포함

for of
반복가능한 객체의 "값" value 반복
배열일시 값 반복
객체 사용불가 ==> Object.keys()사용
프로토타입속성 포함 x
iterable(반복가능한 객체)

객체에서는 ==> for in
배열에서는 ==> for of

<!-- 재귀함수에서 escape가 안되면? -->

재귀함수에서는 자기자신을 호출하는 함수로 탈출 조건이 반드시 필요하다

탈출조건이없을경우 함수는 무한이 반복되게된다

호출스택에 계속 쌓이게된다 ==> 콜스택에 각 함수의 실행컨텍스트를 저장 => 스택오버플로우 발생

<!-- 스택 오버플로우의 결과 -->

콜스택에 메모리가 한계를 초과했을떄 발생하는 오류
재귀함수나 반복적인 함수호출이 탈출조건이 없으면 무한하게 실행되어서 메모리 초과

1. 브라우저 환경에서 발생하는결과 -에러 메시지출력 -프로그램 즉시 중단 -더이상 코드 실행되지않고 크래시 발생 가능

2. 서버 환경에서 발생하는결과 -서버가 다운됨 멈춤 -서비스 장애 발생 위험

메모리구조
-stack 콜스택 (크기가 작고 빠른 메모리)
-heap (배열, 객체 등 동적 데이터)
-code (프로그램 코드 저장)
-static (전역변수 상수)

stack
크기가 작고 빠른 메모리
LIFO 구조
함수 실행시 실행컨텍스트 저장
함수 종료시 컨텍스트 제거

heap
동적 데이터 객체, 배열
크기가 크고 처리속도 느림

스택 오버플로우가 발생하는 이유?

1.  콜스택의 크기제한 -콜스택은 작은 크기의 메모리 -브라우저나 node의 콜스택 크기는 10000~20000번의 호출만 버틸수있음

2.  함수 호출마다 메모리 소비
    매개변수 , 지역변수 , 반환주소 스택에 쌓임
    호출 스택이 계속 쌓여 메모리를 점유

3.  메모리한계 도달
    스택 영역 초과 ==> 힙영역으로 침범

    배열/객체가 힙 메모리에 저장되는 이유는 동적으로 증가할수있기때문임
    ===> 고정크기인 스택에 저장하는게 불가한이유

    대신 힙메모리에 저장하고, 스택에는 참조값(주소값만) 저장한다

    스택오버플로우가 발생하면
    스택에는 참조값만 저장하기때문에 힙 메모리는 직접적인 영향을 받지안흔다
    그러나 스택이 넘쳐서 프로그램이 강제로 종료되면
    힙메모리에서 GC 가비지컬렉팅으로 값들이 정리된다

          <!-- FCP -->

    FCP (First Contentful paint)
    페이지에서 첫번쨰 콘텐츠(텍스트, 이미지 등)이 렌더링되어서 사용자에게 보이는 시간을 측정합니다

    FCP가 빠를수록 페이지가 로딩중 이라는 인식이줄어든다
    사용자에게 빠른 피드백을준다

    SSR ==> FCP가 빠름
    CSR ==> FCP가 느림
     <!-- 코드 스플리팅 -->

    자바스크립트 코드를 기능별로 나누어 필요한 부분만 로드
     <!-- TTI 타임투 인터렉션 -->

    웹 페이지가 사용자와 상호작용을 완벽하게 처리할 준비가된 시점을 말한다

    TTI의 조건

    1. 화면의 주요 컨텐츠가 렌더링된상태
    2. js가 로드및 실해완료
    3. 사용자의 이벤트가 지연없이 응답할수있는 상태

    CSR은 JS의존도가 높기때문에 TTI가 느려질수있다

    이유
    html 뼈대로드
    js파일 다운로드 및 실행 ==> 오래걸림
    API데이터 요청 DOM 렌더링
    상호작용 준비완료

    TTI 도달시점이 느림 JS의 큰 파일 및 html 초기에 로딩이 느리기때문에

    빠른 TTI 하기위한방법

    1. 브라우저 캐싱 활용 (두번쨰 방문부터는 빠르게)
    2. 코드스플릿팅 (페이지에필요한 jS만 로드 초기로딩 다운로드수 감소시키기)
    3. 프리페칭 (다음페이지에 필요한 JS 데이터 미리 다운로드)
    4. lazy loading (페이지 렌더링후 필요한 js 지연로딩)

     <!-- 1극 객체로서 함수 -->

    JS 는 함수를 값처럼 전달, 반환 , 저장가능

           <!-- 고차함수 -->

    다른 함수를 인자로 받거나
    함수를 반환하는 함수를 말한다

          <!-- 순수 함수 -->

    순수함수란 입력에 의존한 출력만 반환하는 함수입니다
    외부상태에 의존하거나 변경하지않음(부수효과없음)
    같은 입력에대해 항상 같은값 반환

    예측가능성
    함수형프로그래밍에 적합
    코드의 안전성 증가

   <!-- DOM 이 생성될떄 파싱, 로드되는거랑 실행되는거? 그것이 무엇인가? -->

    1. html을 로드하고 DOM 트리 생성하기시작함
    2. css를 로드하고 CSSROM 트리를 생성하기시작함 \*\*\*\*중요한게 여기서 기존에하굈던 html파싱은 멈추지않음 병렬적으로 진행함 /// + CSS파싱이 완료될떄까지 렌더링 차단상태
    3. script 태그의 defer가 달려있으면 HTML 파싱을 막지않는다 따라서 DOM 생성 완료까지 파싱을 계속 진행한다//// HTML파싱 완료후 js 실행

    DOMContentLOaded 이벤트 직전에 실행 (DOM트리 구성된상태 html만)
    load 이벤트 (이미지, js까지 다 다운로드된상태)

    렌더링 차단 상태란?
    브라우저가 화면에 콘텐츠를 못그리는 상태
    html은 파싱을완료해서 DOM은 만들어졌지만css가 준비되지않아서 렌드트리 생성을위해 painting이 지연

    dom 파싱 -> css파싱 -> 렌더트리생성 -> defer스크립트 실행 -> DOMcontentLoad 이벤트 발생

   <!-- load, DOMContentLoaded -->

    DOMContentLoaded

    - DOM트리 + CSSROM ==> 렌더트리 만 완성되면 발생 렌더트리!
    - DOM + CSSROM
    - 이시점부터 js로 DOM 조작가능

    load
    -DOM + CSS + 이미지 + JS

   <!-- 왜 DOMContentLoadded는 CSS까지 준비되어야 발생할까? -->

    css는 렌더링 차단요소 이기 때문에
    css가 없으면 렌더 트리 생성이 불가능하고
    렌더트리없이는 화면이 그릴수없음으로 DomContnetLoaded는 지연된다

   <!-- 그렇다면 만약 css가 없는 프로젝트는? 어떻게 가져올까? -->

    css없이 html만 존재하는경우

    렌더링 차단요소가 없음
    css 파일이 없음으로 렌더링 차단없이 html만 파싱
    즉 DOM 트리 완성 = 렌더트리 완성

   <!-- defer썼을때 vs 안썼을때 -->

    썻을때
    DOMContentLoaded 이벤트 발생직전에 js가 실행되기때문에 DOMContentLoaded 발생한시점에 사용가능

    안썻을떄
    script 다운로드 병렬로 이루어지지않음 ==> html 파싱 중단 시키고 다운로드 실행함
    load 이벤트발생직전에 js 가 실행되기때문에 load이벤트 발생후 사용가능
    defer사용하지않으면 html파싱 중지시키고 바로 로드하면서 실행까지함 다운로드끝나자마자 실행

    defer사용해야 ==> dom 조작에 더 안전성과 , 성능최적화가 된다?
    성능최적화가 되는이유는? ==> domcontentLoaded가 발생한시점에 빨리 조작할수있어서? load 발생시점이아니라?
    안전성 ==> 아직 dom이 안그려졌는데 없는요소를 조작하려고할때 오류가난다

   <!-- 함수 호이스팅?  -->

    함수호이스팅은 변수호이스팅과 마찬가지로 마치 코드가 올라가져있는것과 같은원리임
    런타임 이전에 자바스크립트 엔진이 읽는것과같음

   <!-- 메모리 할당구조? -->

    메모리 할당구조는 js코드가 실행되기전에 변수와 함수의 공간이 어떻게 설정되는지 의미

    객체,변수,함수 ==> 메모리(stack, heap)에 저장

    실행 컨텍스트 생성단계

    1. 1단계 생성단계
       코드를 실행 하기전에 변수와 , 함수를 선언하고 메모리에 저장
       함수선언문은 함수자체 코드를 메모리에 저장
       변수는 초기화되지않은 상태를 저장

    2. 실행단계
       코드가 한줄씩 동기적으로 실행될떄 변수 초기화값을 할당
       이때 표현식에 할당된함수는 초기화 후 사용가능

    실제 함수 선언문 vs 함수 표현식
    함수선언문
    foo: function(){console.log(foo)}

    함수표현식
    foo: <uninitialized> (tdz)

    함수선언문은 실행컨텍스트 생성시점에 "함수객체"로 저장
    foo:{
    [[Scopes]]: Lexical Environment,
    [[Call]]: function() { return a + b },
    [[Prototype]]: Function.prototype
    }

    이런식으로 객체안에 저장되게

    함수 선언문은 메모리에 함수객체 자체로 저장

    함수 표현식은 메모리에 변수로 저장 ===> TDZ에걸려있음 ==> 실행시점에 함수객체로 초기화됨

    함수선언문 vs 함수표현식 활용가능성

    함수선언문 -빠른접근이 가능함 ==> 실행전 메모리에 함수객체로 초기화되어있기때문 -초기 로딩 최적화 ===> 유틸리티함수나 전역에서 사용하는 함수 유리

    함수표현식 -지연 초기화 ==> 코드 실행시점에서 함수객체로 초기화됨 ==>동적 함수 생성에 적합 -메모리 절약 ==> 필요할때만 초기화 ==> 코드흐름이 명확

       <!-- 메모리구조 -->

    메모리는 일단
    heap // stack(callstack) 이런식으로 전역에 각각 1개씩있음
    참고로 callStack은 stack안에 포함된요소

    예제 코드
    function foo() {
    ₩
    let a = 10; // Stack
    let obj = { b: 20 }; // Heap
    bar();
    function bar() {
    let c = 30; // Stack
    }
    }
    foo();

    [foo 실행 컨텍스트]
    a → 10 (Stack)
    obj → Heap 주소 참조

    [bar 실행 컨텍스트]
    c → 30 (Stack)

     <!-- 이벤트 전파를 어떻게 인식을할수있을까? 버블링?할떄 -->

    이벤트를 어떻게 인식할수있을까?

버블링이 발생하려면 애초에 자식에 이벤트가 발생한것을 부모가 인식을해야한다라고 생각했다
이벤트 전파는 "브라우저가 자동"으로 감지를 한다.
==> 이벤트가 발생하면 브라우저가 감지하고 이벤트객체를 자동으로생성
===> 이벤트의 관련된 모든정보 포함(target, click위치)

즉 이벤트 감지는? ==> 브라우저가 자동으로
이벤트 전파는? ==> 버블링? 캠쳐링

이벤트가 발생하면 브라우저는 해당요소에서 이벤트가 발생!~~ 했을음을 감지한다
그이후 버블링(자식 => 부모) 과정을 통해 전파하고
전파중인 event는 이벤트객체로 기록되어서 전달된다

따라서 이벤트 버블링을 활용할수있게되고
따라서 이벤트 위임을 가능하게한다 (메모리효율성, 유연성)

Target = 실제 이벤트가일어난곳
currentTarget = 이벤트핸들러가 바인딩된곳

<!-- 비동기에 대한 문제 해결  -->

Promise 객체

async await 진행할때 콜스택 상황
async await으로 비동기 처리를 할때면 async로 되어있는 함수실행컨텍스트가 콜스택에 쌓인다
그안에 settimeout등의 비동기 함수가 실행컨텍스트가 생성되고 바로 종료된다
settimeout의 콜백함수가 바로 태스크 큐에 등록된다
등록되고 Promise객체의 pending상태에서 reject 또는 fullfied 상태가 지정될때까지 기다린다
기다리는 상태에서는 태스크큐에서는 콜스택으로 들어가기위해서 콜스택이 비어있어야한다 이것을 이벤트루프가 진행한다
따라서 아직 async 이 함수 자체가 콜스택을 차지하고있으니
잠시 멈추면서 콜스택에서 해제된다
그리고 콜스택으로 이동한 settimeout의 비동기함수는 promise의 state를 업데이트한다
async의 콜스택이 다시 복구된다

그러면 잠시 중단됐을동안 그 함수는 어디에 가있는것인가?
==> 힙 메모리

async function example() {
console.log("Start");

await Promise.resolve(); // 즉시 완료
console.log("Await 완료!");
}

example();
console.log("동기 코드 완료!");

예시 코드

example() 함수 실행컨텍스트 생성 및 콜스택
console.log("start")호출

prmise객체 생성
.then 즉 await Promise.resolve()는 promise.resolve().then(()=>{console.log("await완료")}) 와같음
.then은 마이크로 큐에 진입

이때 example() 실행컨텍스트 중지

동기적 코드 완료 출력

.then 콜스택으로 돌아와서 진행

awiat 완료 출력

그러면 오류 처리느 떻게하는가?
==> async await에서는 try catch문을 사용한다
try catch문에서는 오류전파는 => 호출자쪽으로 전파된다
콜스택 개념에서 생각해볼수잇는데 실행컨텍스트 가장위에서 밑으로 내려간다 즉 호출자쪽으로 전파되는것이다

따라서 비동기 함수를 사용할때 오류전파 처리를 잘 진행해야한다
예를들면 settimeout으로 try catch문에 넣었을때
settimeout이 콜스택에 쌓이고 타이머 등록후 콜스택에서 제거됨
콜백 함수는 매크로 큐에 추가 → 콜 스택이 비면 실행.
이시점에서는 try..catch문이 존재하지않음 이미

해결방법
settimetout같은경우는 콜백함수안에서 try.catch문사용
promise로 래핑처리
async + try catch 사용

가장중요한점 await은 특수하게 묶고있는 함수를 중지하고 다시 재개할수있다
그래서 콜스택을 비우고 다시넣고할수있기때문에 비동기처리가 가능한것이다

<!-- 동기코드 => 비동기코드(마이크로큐) => 브라우저렌더링 => 비동기코드(메크로큐) -->

const div = document.querySelector("div"); // 동기 코드

Promise.resolve().then(() => {
div.style.color = "red"; // DOM 업데이트 (마이크로태스크)
});

setTimeout(() => {
console.log("setTimeout 실행!"); // 매크로태스크
}, 0);

console.log("동기 코드 완료!");

첫줄 동기코드 먼저실행
동기코드 완료 ! 실행
마이크로큐 테스크 실행
브라우저 렌더링(색상 변경 빨간색으로)
settimeout 실행

<!-- react 사용이유-->

애플리케이션에서 상태와 UI 동기화에 대한 어려움 존재

1. 복잡한 UI 관리 문제 해결

기존 문제 : DOM 조작을 직접 다루었다 특정요소를 업데이트하기위해서 queryselector, addEVnetLisenr
DOM 조작이 많아질수록 코드복잡, 유지보수 비용 증가

React의 해결책 :
react는 단방향 흐름과 컴포넌트기반의 아키텍쳐이용
생태와 ui를 간단하게 동기화할수있게했슴 상태가 변경되면 react는 필요한 부분만 업데이트

2. 컴포넌트 기반 개발
   react의 가장큰 장점
   ui를 컴포넌트 단위로 나눌수있다는점
   기존에는 html, css, js 코드가 서로분리되었는데 이는 코드의 재사용성을 낮추고 유지보수를 어렵게함
   react는 ui를 독자적인 컴포넌트로 나누고 각 컴포넌트가 자신의 상태와 로직을 관리하룻있도록 설계했다
   이를 통해 재사용성과 유지봇성을 높임

<!-- react, next js  -->

react 와 next js 차이점

react는 라이브러리
next js는 프레임워크

react
UI를 만들기위한 도구 단순히 컴포넌트 기반으로 사용자 인터페이스를 구축하는데 필요한 기능만 제공한다

next js
next js는 react기반으로 만들어진 프레임워크 react기능을 확장하여 , SSR,SSG,라우팅, API처리와 같은 기능들을 기본제공

주요차이점 방식
React
클라이언트 사이드 렌더링(csr)만 지원
SSR이 안되는것은아님 지원을 안할뿐 따로 만들어서 사용할수는 있음
브라우저측에서 js를 실행해 사용자 인터페이스를 렌더링한다

next.js
서버사이드렌더링
SSR
SSG

<!--day js, date-fns  -->

js에서 날짜 시간을 쉽게 다룰수있게 도와주는 라이브러리 두 라이브러리는 js의 기본 Date 객체 제한적인것을 보완하고
날짜 / 시간을 처리하는데 필요한 다양한 기능을준다

<!-- 라이브러리란? 무엇인지 -->

라이브러리는 개발자가 소프트웨어를 더 쉽게 작성할수 있도록 특정기능이나 작업을 수행하는 미리 작성된 코드의 모음
라이브러리는 특정한 문제를 해결하귀위해서 작업을 간소화하기위해 만들어짐

<!-- 라이브러리와 프레임워크의 차이  -->

라이브러리
개발자가 필요하고 원하는 기능만 가져다가 사용
개발자가 애플리케이션의 흐름 직접 관리

프레임워크
애플리케이션의 전체 구조를 정의하고 개발자가 그안에서 코드를작성
프레임워크가 애플리케이션의 전체적인 흐름을 관리한다

<!-- Sass, styled component, tailwind css -->

Sass는 css 전처리기 css를 더 강력하게 사용할수있도록한다
Sass는 css를 확장한도구 css문법을 개선하고, 재사용성을 높이기위해

<!-- script async defer -->
<!-- event.target과 event.currentTarget -->
<!-- 상속을 사용하는이유? -->
<!-- 메서드오버라이딩 -->
<!-- 깃 cherry pick, squash -->

<!-- 트레이드오프 가바지지컬렉팅 -->
