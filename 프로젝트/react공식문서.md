컴포넌트 내부의 2가지 로직 유형

1. 렌더링코드
   ui화면을 표시하는 로직
   return문으로 jsx를 반환
   순수한 로직이여야함 => props, state가 주어지면 항상 같은결과를 반환
   부수효과는 x (dom조작, api호출)
   결과값만 계산하는 역할

2. 이벤트핸들러
   사용자와 상호작용하는 로직
   onclick, onChange와 같은 이벤트 속성에 연결
   사용자 동작에따라 부수효과를 일으킬수있음.
   상태 업데이트, 네트워크요청, 라우팅 변경 등

---

\*\*\*\* 순수함수란?
순수함수란. 동일한 입력에대해 동일하게 결과값을 반환함
부수효과가없음 (함수외부의 상태를 변경하거나 외부와 상호작용하지않는다)

\*\*\* 부수효과란? sideEffect
ex) dom직접수정, api요청, 콘솔 로그, 파일읽기쓰기, 전역변수 수정하기, setState호출하기

\*\*\* setState로 값을 바꾸는건 왜 부수효과인가?

1. 상태변경
   setCount(count+1)했을때 내부적으로 react상태를 변경하니까, 즉 state값이 바뀌면 값을 통해서 재렌더링하기때문에 이과정에 컴포넌트 외부의 상태에 영향을 미치는것으로 보니까 부수효과라고봄.
2. 리렌더링 트리거
   상태가 변경되면 컴포넌트가 리렌더링됨, 이것도 부수효과

\*\*\* 리액트에서 렌더링은 두가지

1. 초기렌더링시
2. state, props 변경시

\*\*\* react렌더링과정

1. 트리거 (state, props변경시)
2. 렌더링 (변경된 컴포넌트를 찾아 새로운가상 dom을생성)
3. 커밋(변경사항을 실제 dom에반영 렌더링결과를 브라우저에반영)

\*\*\* 렌더링시 문제점
app 컴포넌트에서 state가변경될떄 하위에 state 넘겨주지않아도 하위에있는 자식들이 모두 리렌더링됨
최적화가능

1.React.memo
2.useMemo
3.useCallback

\*\*즉 useEffect가 뭐냐고했을때

react에서의 렌더링은 순수해야함.
렌더링도중에 부수효과가있으면안됨.
useEffect는를 사용해 렌더링이후에 부수효과를 실행해야함

렌더링시에 부수효과가 없어야하는이유?
=> 렌더링마다 다른결과가 나올수있음, -> 그렇게되면 react의 가상dom비교 과정이 깨지고, 예측이어려워진다.

1. React의 렌더링(Rendering)은 순수해야 한다.
   같은 state와 props가 들어오면, 항상 같은 UI가 나와야 한다.

2. 렌더링 중 부수 효과(API 요청, DOM 조작 등)를 실행하면 안 된다.
   부수 효과는 렌더링을 예측 불가능하게 만들 수 있음.
   가상dom과 실제dom의 비교를 예측할수 없게 만들 수 있다.

3. useEffect는 "렌더링 후 부수 효과를 실행할 수 있도록 보장"하는 역할을 한다.
   적절한 시점(마운트, 업데이트, 언마운트)에 실행 가능.
   의존성 배열을 사용해 "언제 실행할지"를 결정할 수 있다.

useEffect는 화면에 렌더링이 반영될 때까지 코드 실행을 “지연”시킵니다.

렌더링: react가 컴포넌트를 호출하고 jsx를 생성하는과정 가상 DOM을 만든다. virtualDOm을 만든다
마운트 : react가 렌더링된 결과를 실제 dom에 반영하는과정 실제 dom에 적용
언마운트: 컴포넌트가 실제 dom에서 제거되는것을의미

useRef -값을 변경함 -리렌더링 트리거는 아님 -보통 dom을 조작하는데 사용, 또는 변수저장 -불변한 객체임
-.current를 이용하여 사용함

react strict모드

- 리액트의 스트릭트 모드에서는 마운트하고 바로 언마운트 후 다시 마운트 즉 -> mount -> unmount -> mount
- 이럴경우에 mount가 두번되기에 useEffect가 두번실행되는것이고 만약여기안에 settimeout같은 함수가있으면 중복실행이되는 오류가생길수있으니 클린업 함수를 실행해야함.

clean up 함수
