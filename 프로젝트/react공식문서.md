컴포넌트 내부의 2가지 로직 유형

1. 렌더링코드
   ui화면을 표시하는 로직
   return문으로 jsx를 반환
   순수한 로직이여야함 => props, state가 주어지면 항상 같은결과를 반환
   부수효과는 x (dom조작, api호출)
   결과값만 계산하는 역할

2. 이벤트핸들러
   사용자와 상호작용하는 로직
   onclick, onChange와 같은 이벤트 속성에 연결
   사용자 동작에따라 부수효과를 일으킬수있음.
   상태 업데이트, 네트워크요청, 라우팅 변경 등

---

\*\*\*\* 순수함수란?
순수함수란. 동일한 입력에대해 동일하게 결과값을 반환함
부수효과가없음 (함수외부의 상태를 변경하거나 외부와 상호작용하지않는다)

\*\*\* 부수효과란? sideEffect
ex) dom직접수정, api요청, 콘솔 로그, 파일읽기쓰기, 전역변수 수정하기, setState호출하기

\*\*\* setState로 값을 바꾸는건 왜 부수효과인가?

1. 상태변경
   setCount(count+1)했을때 내부적으로 react상태를 변경하니까, 즉 state값이 바뀌면 값을 통해서 재렌더링하기때문에 이과정에 컴포넌트 외부의 상태에 영향을 미치는것으로 보니까 부수효과라고봄.
2. 리렌더링 트리거
   상태가 변경되면 컴포넌트가 리렌더링됨, 이것도 부수효과

\*\*\* 리액트에서 렌더링은 두가지

1. 초기렌더링시
2. state, props 변경시

\*\*\* react렌더링과정

1. 트리거 (state, props변경시)
2. 렌더링 (변경된 컴포넌트를 찾아 새로운가상 dom을생성)
3. 커밋(변경사항을 실제 dom에반영 렌더링결과를 브라우저에반영)

\*\*\* 렌더링시 문제점
app 컴포넌트에서 state가변경될떄 하위에 state 넘겨주지않아도 하위에있는 자식들이 모두 리렌더링됨
최적화가능

1.React.memo
2.useMemo
3.useCallback

\*\*즉 useEffect가 뭐냐고했을때

react에서의 렌더링은 순수해야함.
렌더링도중에 부수효과가있으면안됨.
useEffect는를 사용해 렌더링이후에 부수효과를 실행해야함

렌더링시에 부수효과가 없어야하는이유?
=> 렌더링마다 다른결과가 나올수있음, -> 그렇게되면 react의 가상dom비교 과정이 깨지고, 예측이어려워진다.

1. React의 렌더링(Rendering)은 순수해야 한다.
   같은 state와 props가 들어오면, 항상 같은 UI가 나와야 한다.

2. 렌더링 중 부수 효과(API 요청, DOM 조작 등)를 실행하면 안 된다.
   부수 효과는 렌더링을 예측 불가능하게 만들 수 있음.
   가상dom과 실제dom의 비교를 예측할수 없게 만들 수 있다.

3. useEffect는 "렌더링 후 부수 효과를 실행할 수 있도록 보장"하는 역할을 한다.
   적절한 시점(마운트, 업데이트, 언마운트)에 실행 가능.
   의존성 배열을 사용해 "언제 실행할지"를 결정할 수 있다.

useEffect는 화면에 렌더링이 반영될 때까지 코드 실행을 “지연”시킵니다.

렌더링: react가 컴포넌트를 호출하고 jsx를 생성하는과정 가상 DOM을 만든다. virtualDOm을 만든다
마운트 : react가 렌더링된 결과를 실제 dom에 반영하는과정 실제 dom에 적용
언마운트: 컴포넌트가 실제 dom에서 제거되는것을의미

useRef -값을 변경함 -리렌더링 트리거는 아님 -보통 dom을 조작하는데 사용, 또는 변수저장 -불변한 객체임
-.current를 이용하여 사용함

react strict모드

- 리액트의 스트릭트 모드에서는 마운트하고 바로 언마운트 후 다시 마운트 즉 -> mount -> unmount -> mount
- 이럴경우에 mount가 두번되기에 useEffect가 두번실행되는것이고 만약여기안에 settimeout같은 함수가있으면 중복실행이되는 오류가생길수있으니 클린업 함수를 실행해야함.

clean up 함수

\*\* 리액트 렌더링시 바뀌는것과 안바뀌는것
리액트 컴포넌트의 내부함수,내부변수와 dom 은 다른 개념임
즉 리렌더링이 시작되면 state가 변경값을 인지할수있는것은
react 내부에서 state의 변경값을 가지고잇음 === 즉 해당컴포넌트 밖에서 값을 유지하고있음
리렌더링하고 실제 dom에 커밋할떄
내부함수, 내부변수는 새로만들어짐. 하지만 실제 dom과 가상 dom을 비교했을떄 태그들, 즉 dom은 변경사함없으면 기존으로 유지

렌더트리를 컴포넌트를 가지고 만든다.
컴포넌트에 state를 줄때 state가 컴포넌트안에 살고있다라고 생각하는데 사실 state는 react안에있다.
react는 컴포넌트가 ui트리에 있는 위치를 이용해서 react가 가지고있는 각 state를 알맞은 컴포넌트에 연결한다.

React는 컴포넌트의 "위치"를 기준으로 상태를 유지하거나 초기화한다.

조건부 렌더링({showB && <Counter />}) → 컴포넌트가 제거되었다가 다시 추가됨 → useState 초기화됨
같은 자리에 있는 컴포넌트의 props가 변경됨 (isFancy 변경) → React가 같은 컴포넌트로 인식 → useState 유지됨
즉, "같은 자리에 있다"는 것은 React가 "같은 컴포넌트"라고 판단하는 것이고, "같은 자리에 없다"는 것은 React가 "새로운 컴포넌트"라고 판단하여 상태를 초기화하는 것!

\*\*\* 리액트에서 배치로 state들이 한꺼번에 처리되는이유
React에는 브라우저의 이벤트 루프와는 별개로 자체적인 "업데이트 대기열(State Update Queue)"이 존재
React는 자체적인 이벤트 루프를 따로 운영하는 것이 아니라, JavaScript의 이벤트 루프를 활용하면서 React 내부에서 최적화된 방식으로 상태 업데이트를 관리하는 큐를 사용
React는 상태 업데이트가 발생할 때, 즉시 상태를 변경하지 않고, "업데이트 대기열(Queue)"에 추가한 후 배치 처리(Batching)하여 한 번만 렌더링하는 최적화 기법을 사용

이벤트루프 : javascript꺼사용
업데이트 큐 : 리액트 자체적인것 사용 ==> setCount같은거 모아다가 한번에 실행

개별로실행할수있음
setCount(count+1)
await 어떤함수
setCount(count +1)
이런식으로 진행되면 첫번째 setCount는 업데이트큐에들어가는데. awiat 어떤함수를 진행함으로써 자바스크립트의 이벤트루프가돌기때문에 batch처리 불가능해짐
그렇다는건 1번 렌더링되고 두번쨰 setCount에 의해서 2번렌더링된다는것임
