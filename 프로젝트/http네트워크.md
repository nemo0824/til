IP 프로토콜
인터넷망에서 송신 수신을 할때 룰

IP패킷규칙 (출발지ip, 목적지ip, 기타 , 전송 데이터)
node 안에서 움직이면서 최종 목적지ip 주소까지 도달한다

IP프로토콜의 한계
1. 비연결성 
 - 패킷을 받을 대상이없거나 서비스 불능 상태여도 패킷 전송(즉 대상이 없어도 보내진다)
2. 비신뢰성
 - 패킷의 유실
 - 패킷의 순서대로 안옴
3. 프로그램 구분
 - 같은 IP사용하는 서버에서 통신하는 애플리케이션이 두개이상일시?


이러한 IP프로토콜 문제들을 개선하기 위해서 나온것들 

TCP/UDP

인터넷프로토콜 스택의 4계층
애플리케이션 -> 전송계층 -> 전송계층 -> 네트워크 인터페이스 계층

프로토콜 계층
애플리케이션(웹브라우저,채팅프로그램) -> os(tcp, ip, udp) -> 네트워크 인터페이스(lan카드)
 
 ip패킷 - tcp 세그먼트
 (출발지ip, 목적지ip   (출발지port, 목적지port, 전송제어, 순서 , 검증 정보    (전송 정보) ))

 

 TCP특징 
 전송제어 프로토콜
 연결지향 - TCP 3way handShake (가상 연결 개념적으로만 연결이된것 ) 연결후에 메시지를 보냄 (syn -> <- syn+ Ack  ACK->)
 데이터 전달 보증 (유실 방지)
 순서 보장

 신뢰할수있는 프로토콜
 현재 대부분 TCP 사용

 UDP 
 사용자 데이터 그램 프로토콜
 연결지향 x
 데이터 전달 보증 x
 순서 보장 x
 데이터 전달 및 순서 보장 x 속도 빠름 
 즉 == IP와 거의같음 

port 사용 이유 ===> 데이터 전송시 1개의 ip 즉 본인의ip로 전송을 받고 어떤 어플리케이션인지 구분하는용도
IP와 거의 같다 + Port + 체크썸 정도만 추가

최근에는 UDP가 뜨고있음 


PORT 
같은 IP 내에서 프로세스 구분
클라이언트가 여러개의 서버를 통신할떄 
즉 예를들면    대한민국 경기도  대한민국이 IP 경기도가 Port
            아파트 ip 호수 port


DNS
IP는 바뀔수 있다
전화번호부처러 DNS 도메인을 사용한다


URI 와 웹 브라우저 요청 흐름

URI 
웹 브라우저 요청 흐름 

Uniform Resource Indentfier

URI가 큰개념 자식들로 URL, URN

리소스의 위치
리소스의 이름 

URI 
Uniform 리소스를 식별하는 통일된 방식
Resource 자식, URI로 식별할수 있는 모든것 
Identifier 다른 항목과 구분하는데 필요한 정보

URN이름만으로 실제 리소스를 찾을수 있는 방법이 보편화 되지않음


URL
프로토콜 호스트명 포트번호 패스 쿼리 파라미터

스키마 
프로토콜: 어떤방식으로 자원을 접근할것인가 약속규칙
http, https , ftp 등등
http는 80 https 443 주로 사용 

쿼리파라미터, 쿼리스트링

fragment

prot 


웹브라우저 요청 흐름
https://www.google.com:443/search?q=hello&hl=ko

DNS 조회 IP 200.200.200.2
port는 443 생략
http요청 메시지 생성

http 메시지 전송
1. 웹 브라우저가 HTTP 메시지 생성
2. SOCKET 라이브러리를 통해 전달
 A: TCP/IP 연결(IP, PROT)
 B: 데이터 전달
3. TCP/IP 패킷 생성 HTTP 메시지 포함


출발 IP PORT
목적지 IP PORT로 감싸기 
 GET/search ? qq = hello & hl =ko HTTP/1.1 Host: www.google.com


 HTTP
 HTTP메시지에 모든것을 전송
 HTML,Text, Image, JSON, xml 서버간의 데이터 주고받을떄 HTTP 사용
 
 
 HTTP/1.1 가장 많이사용 

TCP: HTTP/1.1, HTTP/2
UDP: HTTP/3 (성능최적화 udp 속도를 위해서)
현재 HTTP/1.1주로 사용

Http특징 
클라이언트 서버구조 
무상태 프로토코 ㄹ비연결성
HTTP 메시지 
단순함, 확장가능

-클라이언트 서버구조
Request Response 구조
클라이언트는 서버에 요청을 보내고 응답을 대기 
서버가 요청에대한 결과를 만들어서 응답 

예) 복잡한 비지니스 로직이랑 화면을 구분하여  즉 프론트엔드와 백엔드를 구별하여
앞단쪽에서는 백쪽의 비지니스 로직을 몰라도되고 
화면에만 더 집중할수있음

백쪽에서는 아키텍쳐나 대용량 트래픽을 어떻게 다룰지 더 고심할수있게됨

-무상태 프로토콜
서버가 클라이언트 상태를 보존x
장점 : 서버 확장성 높은 (스케일 아웃)
단점 : 클라이언트가 추가 데이터전손

상태를 유지하지않음 
ex) 점원이 바뀌어도 어떻게할지 알수있음 
확장성이 높다 

상태 유지를하면 
문맥이 없어지면 어떻게 할지 모름 
