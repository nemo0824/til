
### 코어 자바스크립트
딥다이브를 목표로 책을 회독한다


### 1.데어터 타입
데이터 타입은  크게 기본형과 참조형으로 나뉜다
기본형 : 숫자 , 문자열, boolean, null, undefined, 심볼
참조형 : 객체 , 배열, 함수 ,날짜 ,정규표현식

기본형 vs 참조형 어떤차이인가? 

기본형은 복제되고 
참조형은 참조된다 

이해를 위해서 그림으로 이해하는게 더 편하다 

배경지식부터 하게되면
컴퓨터는 모든값을 0 과 1로 바꿔서 저장한다
0과 1을 표한하는 메모리를 비트 라고부란다
각 비트는 식별자를 통해 위치를 확인할수있다

비트를 몇개 묶어서 하나의 단위로 여기는게 바이트 이다 
1바이트는 8비트 로 구성된다

모든 데이터는 바이트 단위의 식별자 
메모리 주솟값을 통해서로 구분하고 연결한다



변수 영역 /// 데이터 영역으로 구분을 한다
```javascript 
var a; 
a= 'abc'
```

1. a라는 변수를 할당하는 변수 영역을 1002번 째 메모리에 설정했다고치면  
변수 영역 1002 주소 (변수명 = a,값 ??)   =======> 1002번 빈공간을 확보하고  이름을 a 값은 아직 ?? 

2.abc를 할당
abc라는 값이 있는지 즉 미리 선언되어있는지 확인 후 없으면
데이터영역으로 가서 5004번에 빈공간을 확보 문자열 'abc'를 저장
데이터 영역 5004 주소('abc')저장 
변수 영역에서 a라는 식별자를 검색한다 (@1002)
5004를 1002번주소에 값으로 저장해줌 


즉 ===> 1002주소(변수영역 이름: a 값: 5004) ====> 5004주소(데이터 영역: "abc")


why? 직접 대입안하고 한번더 주소를 확보해서 불편스럽게할까?????????
====> 데이터변환 확장성을 늘리고, 메모리를 효율적으로 관리하기위해서 
=======> why? 확장성이 늘리고 효율적일까? 
=======> 숫자는 64비트 즉 8바이트  한글은 2바이트 영어는 1바이트
========> 글자수가 굉장히 가변적, 용량도 가변적
-==============> 미리 확보한 공간 내에서만 데이터 변환을 할수있다면 변환한 데이터를 다시저장 하기위해서 확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업을해야함
==================> 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐 

변수 상수 나누는기준 ===> 변수영역의 메모리
불변성의 여부를 나누는기준 ====> 데이터 영역의 메모리

```javascript 
var obj1 ={
    a:1, 
    b: 'dddd'
}
```

1. obj1 이라는 변수를 1002번 메모리 빈공간을 확보
2. 데이터영역 5001번에 7103 이라는 주소를 연결
3. 7103에는 이름 a 값은 5003번
3. 7104에는 이름 b 값은 5004번
4. 5003에는 1 5004에는 'ddd'


### 2. 실행 컨텍스트

실행 컨텍스트 
실행할 코드에 제공할 환경 정보들을 모아놓은 객체

실행 컨텍스트의 구성도
1 VariableEnvironment --- 1-1. environmentRecord 1-2. outerEnvironmentReference
2 LexicalEnvironment  --- 2-1. environmentRecord  2-2. outerEnvironmentReference
3 ThisBinding

VariableEnvironment === LexicalEnvironment 
VariableEnvironment 는 최초 실행시의 스냄샶을 유지한다
LexicalEnvironment 는 변경사항을 실시가능로 반영됨

 1-1, 2-1 environmentRecord (호이스팅)
 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다
 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명을 다 알고잇는 상황  
 ====> 호이스팅 개념 
 
 1-2 2-2 outerEnvironmentReference (스코프체인, 스코프)
 전역 컨텍스트에서는 아무것도 담기지않음 

 outer 컨텍스트에서는 ---> [Global, {a, outer}]
 inner 컨텍스트 에서는  ----> [outer, {inner}]

 ```javascript 
var a = 1;
var outer = function(){
    var inner = function(){
        console.log(a)
        var a = 3
    };

    inner();
    console.log(a)
}
outer();
console.log(a)

```


### 3. this
this는 클래스로 생성한 인스턴스의 객체를 말한다 
자바스크립트에서는 this는 상황에 따라 this가 바라보는 대상이 달라진다 

실행컨텍스트가 생성될떄 this가 결정된다 
실행컨텍스트는 함수를 호출할떄 생성한다 ==> 따라서 this는 함수를 호출할떄 결정된다

3-1-1 전역공간에서 this
전역공간에서 this는 브라우저환경에서 window 즉 전역객체를 뜻한다 
nodeJs 환겨에서는 global 

전역변수를 선언하면 자바스크립트엔진은 전역객체의 프로퍼티로 할당하는것이다

var a = 1;
window.a 랑 같다 
자바스크립트의 모든 변수는 특정객체의 프로퍼티이다 

window.a === var a === this.a 같다 

하지만 둘의 차이점이있는경우 "삭제" 명령어를 실행할떄

var a= 1; 
delete window a // false

var b= 2;
delete b; //false

window.c = 3; 
delete window.c; //true

window.d = 4
delete d //true 

window로 선언한 변수는 delete 명령어 잘됨  var 로 선언한 변수는 delete 명령어 안됨

전역변수로 선언하면 ===> configurable false로 설정되기때문
전역객체로 선언하면 ===> configurable true로 설


3-1-2 메서드로서 호출할떄 그메서드 내부에서의 this

함수로서 호출 vs 메서드로서 호출
함수로서 호출 ==> 독립성
메서드로서 호출 ==> 대상 객체에 관련된 동작 수행

3-1-3 함수로서 호출할떄 그 함수 내부에서 this
this는 전역 객체를 바라본다 

함수--
어떤함수를 함수로서 호출한경우에는 this가 지정되지않는다 ==> this가 지정되지않는경우는 this는 전역객체를 바라본다

메서드 --
메서드 내부에서 정의하고 실행함 함수 
. 이없으면 함수로서 호출되었기때문에 전역객체를 바라본다

우회하는 방법 
1.화살표 함수 
 화살표함수는 this를 바인딩하지않는다 
 실행 컨텍스트를 생성할때 this 바인딩과정이 아예 빠지기때문에 상위 스코프의 this를 그대로 활용한다 

2.Call,apply,bind 

3-1-4 콜백함수 호출시 그 함수 내부에서 this
settimeout
forEach
addevnetlisnter 

함수A의 제어권을 다른 함수 B에게 넘겨주는경우 함수A를 콜백함수라고한다

3-1-5 생성자함수 
new 키워드 사용해서 생성자함에서는 
새로생성될 인스턴스를 가리킨다

3-2 명시적으로 this를 바인딩하는방법

3-2-1 call 
메서드의 첫번째 인자를 this로 바인딩 그이후 인자들을 매개변수로
3-2-2 apply
메서드의 첫번째 인자를 this로 바인딩 그이후 인자들을 매개변수로
매개변수를 배열로 

3-2-3
call, apply 이용시 
유사배열객체 또는 문자열등을 배열메서드를 사용가능함 

3-2-4
call 과 비슷하지만 즉시 호출하지않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드
bind 메서드는 함수에 this를 미리 적용하는것과 부분 적용 함수를 구현하는 두가지 목적

call vs bind
call
즉시 호출, 반환값 없음 특정객체에 대한 메서드를 즉시호출하고자할때사용

bind
새로운 함수생성, 반환값: 새로운함수, 나중에 호출할수있는 함수의 this를 고정할때 사용

 ```javascript 
const obj = {
    name: 'Diana',
    greet: function() {
        setTimeout(() => {
            console.log(`Hi, ${this.name}`);
        }, 500);
    }
};

obj.greet();
 ```

 1.obj.greet호출시 
 obj.greet 실행되면 ==> greet메서드의 내부에서 this는 obj

 2.setTimeout 호출 
 settimeout은 전역함수 *********** 여기서는 실행컨텍스트에 영향안줌 ***********
 단순하게 타이머가 끝났을때만 실행할 콜백함수를 예약할뿐임
 따라서 setTimeout자체가 this에 영향을 주는게아니라 오로지 setTimeOut안의 콜백함수가 어떻게 this를 참조하는지만 보면됨
 