
### 코어 자바스크립트
딥다이브를 목표로 책을 회독한다


### 1.데어터 타입
데이터 타입은  크게 기본형과 참조형으로 나뉜다
기본형 : 숫자 , 문자열, boolean, null, undefined, 심볼
참조형 : 객체 , 배열, 함수 ,날짜 ,정규표현식

기본형 vs 참조형 어떤차이인가? 

기본형은 복제되고 
참조형은 참조된다 

이해를 위해서 그림으로 이해하는게 더 편하다 

배경지식부터 하게되면
컴퓨터는 모든값을 0 과 1로 바꿔서 저장한다
0과 1을 표한하는 메모리를 비트 라고부란다
각 비트는 식별자를 통해 위치를 확인할수있다

비트를 몇개 묶어서 하나의 단위로 여기는게 바이트 이다 
1바이트는 8비트 로 구성된다

모든 데이터는 바이트 단위의 식별자 
메모리 주솟값을 통해서로 구분하고 연결한다



변수 영역 /// 데이터 영역으로 구분을 한다
```javascript 
var a; 
a= 'abc'
```

1. a라는 변수를 할당하는 변수 영역을 1002번 째 메모리에 설정했다고치면  
변수 영역 1002 주소 (변수명 = a,값 ??)   =======> 1002번 빈공간을 확보하고  이름을 a 값은 아직 ?? 

2.abc를 할당
abc라는 값이 있는지 즉 미리 선언되어있는지 확인 후 없으면
데이터영역으로 가서 5004번에 빈공간을 확보 문자열 'abc'를 저장
데이터 영역 5004 주소('abc')저장 
변수 영역에서 a라는 식별자를 검색한다 (@1002)
5004를 1002번주소에 값으로 저장해줌 


즉 ===> 1002주소(변수영역 이름: a 값: 5004) ====> 5004주소(데이터 영역: "abc")


why? 직접 대입안하고 한번더 주소를 확보해서 불편스럽게할까?????????
====> 데이터변환 확장성을 늘리고, 메모리를 효율적으로 관리하기위해서 
=======> why? 확장성이 늘리고 효율적일까? 
=======> 숫자는 64비트 즉 8바이트  한글은 2바이트 영어는 1바이트
========> 글자수가 굉장히 가변적, 용량도 가변적
-==============> 미리 확보한 공간 내에서만 데이터 변환을 할수있다면 변환한 데이터를 다시저장 하기위해서 확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업을해야함
==================> 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐 

변수 상수 나누는기준 ===> 변수영역의 메모리
불변성의 여부를 나누는기준 ====> 데이터 영역의 메모리

```javascript 
var obj1 ={
    a:1, 
    b: 'dddd'
}
```

1. obj1 이라는 변수를 1002번 메모리 빈공간을 확보
2. 데이터영역 5001번에 7103 이라는 주소를 연결
3. 7103에는 이름 a 값은 5003번
3. 7104에는 이름 b 값은 5004번
4. 5003에는 1 5004에는 'ddd'


### 2. 실행 컨텍스트

실행 컨텍스트 
실행할 코드에 제공할 환경 정보들을 모아놓은 객체

실행 컨텍스트의 구성도
1 VariableEnvironment --- 1-1. environmentRecord 1-2. outerEnvironmentReference
2 LexicalEnvironment  --- 2-1. environmentRecord  2-2. outerEnvironmentReference
3 ThisBinding

VariableEnvironment === LexicalEnvironment 
VariableEnvironment 는 최초 실행시의 스냄샶을 유지한다
LexicalEnvironment 는 변경사항을 실시가능로 반영됨

 1-1, 2-1 environmentRecord (호이스팅)
 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다
 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명을 다 알고잇는 상황  
 ====> 호이스팅 개념 
 
 1-2 2-2 outerEnvironmentReference (스코프체인, 스코프)
 전역 컨텍스트에서는 아무것도 담기지않음 

 outer 컨텍스트에서는 ---> [Global, {a, outer}]
 inner 컨텍스트 에서는  ----> [outer, {inner}]

 ```javascript 
var a = 1;
var outer = function(){
    var inner = function(){
        console.log(a)
        var a = 3
    };

    inner();
    console.log(a)
}
outer();
console.log(a)

```


### 3. this
this는 클래스로 생성한 인스턴스의 객체를 말한다 
자바스크립트에서는 this는 상황에 따라 this가 바라보는 대상이 달라진다 

실행컨텍스트가 생성될떄 this가 결정된다 
실행컨텍스트는 함수를 호출할떄 생성한다 ==> 따라서 this는 함수를 호출할떄 결정된다

3-1-1 전역공간에서 this
전역공간에서 this는 브라우저환경에서 window 즉 전역객체를 뜻한다 
nodeJs 환겨에서는 global 

전역변수를 선언하면 자바스크립트엔진은 전역객체의 프로퍼티로 할당하는것이다

var a = 1;
window.a 랑 같다 
자바스크립트의 모든 변수는 특정객체의 프로퍼티이다 

window.a === var a === this.a 같다 

하지만 둘의 차이점이있는경우 "삭제" 명령어를 실행할떄

var a= 1; 
delete window a // false

var b= 2;
delete b; //false

window.c = 3; 
delete window.c; //true

window.d = 4
delete d //true 

window로 선언한 변수는 delete 명령어 잘됨  var 로 선언한 변수는 delete 명령어 안됨

전역변수로 선언하면 ===> configurable false로 설정되기때문
전역객체로 선언하면 ===> configurable true로 설


3-1-2 메서드로서 호출할떄 그메서드 내부에서의 this

함수로서 호출 vs 메서드로서 호출
함수로서 호출 ==> 독립성
메서드로서 호출 ==> 대상 객체에 관련된 동작 수행

3-1-3 함수로서 호출할떄 그 함수 내부에서 this
this는 전역 객체를 바라본다 

함수--
어떤함수를 함수로서 호출한경우에는 this가 지정되지않는다 ==> this가 지정되지않는경우는 this는 전역객체를 바라본다

메서드 --
메서드 내부에서 정의하고 실행함 함수 
. 이없으면 함수로서 호출되었기때문에 전역객체를 바라본다

우회하는 방법 
1.화살표 함수 
 화살표함수는 this를 바인딩하지않는다 
 실행 컨텍스트를 생성할때 this 바인딩과정이 아예 빠지기때문에 상위 스코프의 this를 그대로 활용한다 

2.Call,apply,bind 

3-1-4 콜백함수 호출시 그 함수 내부에서 this
settimeout
forEach
addevnetlisnter 

함수A의 제어권을 다른 함수 B에게 넘겨주는경우 함수A를 콜백함수라고한다

3-1-5 생성자함수 
new 키워드 사용해서 생성자함에서는 
새로생성될 인스턴스를 가리킨다

3-2 명시적으로 this를 바인딩하는방법

3-2-1 call 
메서드의 첫번째 인자를 this로 바인딩 그이후 인자들을 매개변수로
3-2-2 apply
메서드의 첫번째 인자를 this로 바인딩 그이후 인자들을 매개변수로
매개변수를 배열로 

3-2-3
call, apply 이용시 
유사배열객체 또는 문자열등을 배열메서드를 사용가능함 

3-2-4
call 과 비슷하지만 즉시 호출하지않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드
bind 메서드는 함수에 this를 미리 적용하는것과 부분 적용 함수를 구현하는 두가지 목적

call vs bind
call
즉시 호출, 반환값 없음 특정객체에 대한 메서드를 즉시호출하고자할때사용

bind
새로운 함수생성, 반환값: 새로운함수, 나중에 호출할수있는 함수의 this를 고정할때 사용

 ```javascript 
const obj = {
    name: 'Diana',
    greet: function() {
        setTimeout(() => {
            console.log(`Hi, ${this.name}`);
        }, 500);
    }
};

obj.greet();
 ```

 1.obj.greet호출시 
 obj.greet 실행되면 ==> greet메서드의 내부에서 this는 obj

 2.setTimeout 호출 
 settimeout은 전역함수 *********** 여기서는 실행컨텍스트에 영향안줌 ***********
 단순하게 타이머가 끝났을때만 실행할 콜백함수를 예약할뿐임
 따라서 setTimeout자체가 this에 영향을 주는게아니라 오로지 setTimeOut안의 콜백함수가 어떻게 this를 참조하는지만 보면됨

 ```javascript 
 var obj = {
    name: 'Alice',
    logNameLater: function() {
        setTimeout(function() {
            console.log(this.name); // 여기가 핵심
        }.bind(this), 1000); // bind(this)의 위치
    }
};

obj.logNameLater();
 ```

 bind의 위치를 봐야하는데 
obj.logNameLater(); 호출됐을때 ====> this === obj
setTimeout안에 콜백함수는 일반함수 ===> this는 전역이여야함
하지만 .bind로 this 즉 그시점에 logNameLater()함수안에 this는 obj 이기때문에 고정으로 해주는것


### 4. 콜백함수 
콜백함수란 다른코드의 인자로 넘겨주는 행위

콜백함수 다른 코에 인자 넘겨줌으로서 그 제어권도 함께 넘긴다 (제어권을 넘긴다!) - 호출시점에대한 제어권

인자 
Array.protype.map(callback[,thisArg])

map은 첫번째 인자로 callback함수를 받고 생략가능한 두번쨰 인자로 콜백함수내부에서 this로 인식할수있는 대상을 특정할수있다
thisArg를 생략한경우는 전역객체가 바인딩된다

this가 전역객체로 보통 참조하지만 제어권을 넘겨받을 코드에 콜백함수에 별도로 this가될 대상을 지정하는 경우에는 그 대상을 참조하게된다

콜백함수는 함수다
콜백함수로 어떤객체의 메서드를 전달하더라도 그메서드는 메서드가아닌 함수로서 출력되게된다

콜백함수 내부의 this에 다른값바인딩하기 
1. 전통적인방식 sef=this 
2. this를 사용하지않고 고정으로
3. bind를 이용하는방식

콜백함수는 콜백지옥에 빠지기쉽다 

주로 이벤트처리 또는 서버통신 같은 비동기적인 작업을 수행하기위해 이런형태가 자주등장한다

동기적 코드  ==> 순서대로 진행하면서 처리가 끝나지않으면 다음것을 처리하지않음
비동기적 코드 ==> 순서대로 진행하면서 결과값이 안나와도 다음것을 처리함

만약 a의작업의 결과값이 b 작업에 필요할때 
비동기 처리를해줘야함
callback, promise, async awiat



### 5. 클로저의 의미 및 원리이해 
클로저
```javascript
var outer = function(){
    var a = 1;
    var inner = function() {
        console.log(++a)
    }
    inner() //내부호출
}

outer()

```

outer() 함수 실행 컨텍스트 생성

inner() 함수 실행 컨텍스트 생성

inner() ===> 실행컨텍스트 종료 

outer() ====> 실행컨텍스트 종료

outer실행컨텍스트가 종료되면서 (a, inner) 대한 참조를 지움

===> 자신을 참조하는 변수가 없어짐으로 가비지 컬렉터의 수집대상

```javascript
var outer = function(){
    var a = 1;
    var inner = function() {
       return ++a
    }
    return inner() //return 으로 호출 
}

outer()

```
outer() 함수 실행 컨텍스트 생성 ===> a , inner

inner실행 컨텍스트 생성 ===> a=2

inner 실행 컨텍스트 종료 ====> inner의 실행컨텍스트 사라짐

outer 실행 컨텍스트종료 ===> inner()의 결과 반환후 outer함수의 실행컨텍스트도 종료


```javascript
var outer = function(){
    var a = 1;
    var inner = function() {
       return ++a
    }
    return inner //호출안하고 그냥 inner함수를 보냄 
}

var outer2 = outer() //outer() === inner

outer2() // outer2() ====inner() 

```

var outer2 = outer() 이부분에서 
outer 실행컨텍스트가 생성  environemntRecord에 a, inner  outerenvironemnt에 {outer}

outer 실행 컨텍스트가 종료 

outer2()를 사용하여 inner() 함수 실행시킨거와 같으니 
inner 실행컨텍스트가 생성  
스코프체이닝에 따라 outer함수의 실행컨텍스트 변수 a 를 사용 
*** 중요한부분이 일단 outer 실행컨텍스트는 종료됐다는 사실 하지만 참조할수있다 
===> 왜 ? 참조할수있느냐? 
====> 가바지컬렉터의 동작방식때문에 어떤값을 ㅊ마조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지않는다

클로저란 어떤함수 A에서 선언한 변수 a를 참조하는 내함수 B를 외부로 전달할경우 A의 실행컨텍스트가 종료된 이후에 변수 a 가 사라지지않는 현상을 말함


클로저와 메모리 관리 
메모리소모는 클로저의 본질적인 특성이다
메모리 누수 라는 표현은 개발자의 의도와 달리 어떤값의 참조 카운트가 0이 되지않게 설계한것이 맞고

일부러 메모리 참조 카운트를 0을 안만드는것은 누수가아니다

클로저에는 많은 예제가있어서 분석중임 ===> 

~~주말까지  프로토타입및 클래스까지 회독 
그이후에 2단원씩 회독